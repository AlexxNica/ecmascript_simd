<!doctype html>
<head><meta charset="utf8">
<title>SIMD.js specification v0.8.3</title>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
</head><body><emu-biblio href="./biblio.json"></emu-biblio>
<h1>SIMD.js specification v0.8.3</h1>
<div><h2>Table of Contents</h2><ol class="toc"><li><a href="#intro"><span class="secnum"></span> Introduction</a></li><li><a href="#terms-and-defs"><span class="secnum">1</span> Terms and definitions (4.3)</a><ol class="toc"><li><a href="#primitive-def"><span class="secnum">1.1</span> primitive value (4.3.2)</a></li><li><a href="#simd-meta-var-def"><span class="secnum">1.2</span> <var>SIMD</var></a></li><li><a href="#simd-meta-var-def"><span class="secnum">1.3</span> <var>SIMD</var>Descriptor</a></li><li><a href="#simd-type-def"><span class="secnum">1.4</span> SIMD types</a></li><li><a href="#simd-value-def"><span class="secnum">1.5</span> SIMD value</a></li><li><a href="#simd-object-def"><span class="secnum">1.6</span> SIMD object, or SIMD wrapper object</a></li><li><a href="#simd-type-descriptor-def"><span class="secnum">1.7</span> SIMD type descriptor</a></li><li><a href="#simd-boolean-type"><span class="secnum">1.8</span> SIMD boolean type</a></li><li><a href="#simd-integer-type"><span class="secnum">1.9</span> SIMD integer type</a></li><li><a href="#simd-floating-point-type"><span class="secnum">1.10</span> SIMD floating-point type</a></li><li><a href="#simd-signed-integer-type"><span class="secnum">1.11</span> SIMD signed integer type</a></li><li><a href="#simd-unsigned-integer-type"><span class="secnum">1.12</span> SIMD unsigned integer type</a></li></ol></li><li><a href="#types"><span class="secnum">2</span> ECMAScript Data Types and Values (6)</a><ol class="toc"><li><a href="#all-types"><span class="secnum">2.1</span> ECMAScript language types (6.1)</a><ol class="toc"><li><a href="#object-type"><span class="secnum">2.1.1</span> The Object Type (6.1.7)</a><ol class="toc"><li><a href="#intrinsics"><span class="secnum">2.1.1.1</span> Well-Known Intrinsic Objects (6.1.7.4)</a></li></ol></li></ol></li><li><a href="#simd-types"><span class="secnum">2.2</span> SIMD types</a><ol class="toc"><li><a href="#float32x4"><span class="secnum">2.2.1</span> Float32x4</a></li><li><a href="#int32x4"><span class="secnum">2.2.2</span> Int32x4</a></li><li><a href="#int16x8"><span class="secnum">2.2.3</span> Int16x8</a></li><li><a href="#int8x16"><span class="secnum">2.2.4</span> Int8x16</a></li><li><a href="#uint32x4"><span class="secnum">2.2.5</span> Uint32x4</a></li><li><a href="#uint16x8"><span class="secnum">2.2.6</span> Uint16x8</a></li><li><a href="#uint8x16"><span class="secnum">2.2.7</span> Uint8x16</a></li><li><a href="#bool32x4"><span class="secnum">2.2.8</span> Bool32x4</a></li><li><a href="#bool16x8"><span class="secnum">2.2.9</span> Bool16x8</a></li><li><a href="#bool8x16"><span class="secnum">2.2.10</span> Bool8x16</a></li></ol></li></ol></li><li><a href="#abstract-operations"><span class="secnum">3</span> Abstract Operations (7)</a><ol class="toc"><li><a href="#type-conversion"><span class="secnum">3.1</span> Type Conversion (7.1)</a><ol class="toc"><li><a href="#to-primitive"><span class="secnum">3.1.1</span> ToPrimitive ( input [, PreferredType] ) (7.1.1)</a></li><li><a href="#to-boolean"><span class="secnum">3.1.2</span> ToBoolean ( argument ) (7.1.2)</a></li><li><a href="#to-number"><span class="secnum">3.1.3</span> ToNumber ( argument ) (7.1.3)</a></li><li><a href="#to-string"><span class="secnum">3.1.4</span> ToString ( argument ) (7.1.12)</a></li><li><a href="#to-object"><span class="secnum">3.1.5</span> ToObject ( argument ) (7.1.13)</a></li></ol></li><li><a href="#require-object-coercible"><span class="secnum">3.2</span> RequireObjectCoercible ( argument ) (7.2.1)</a></li><li><a href="#same-value"><span class="secnum">3.3</span> SameValue(x, y) (7.2.9)</a></li><li><a href="#same-value-zero"><span class="secnum">3.4</span> SameValueZero(x, y) (7.2.10)</a></li><li><a href="#abstract-relational-comparison"><span class="secnum">3.5</span> Abstract Relational Comparison (7.2.11)</a></li><li><a href="#abstract-equality"><span class="secnum">3.6</span> Abstract Equality Comparison (7.2.12)</a></li><li><a href="#strict-equality-comparison"><span class="secnum">3.7</span> Strict Equality Comparison (7.2.13)</a></li></ol></li><li><a href="#typeof"><span class="secnum">4</span> The typeof Operator (12.5.6)</a><ol class="toc"><li><a href="#typeof-evaluation"><span class="secnum">4.1</span> Runtime Semantics: Evaluation (12.5.6.1)</a></li></ol></li><li><a href="#addition"><span class="secnum">5</span> The Addition operator ( + ) (12.7.3)</a><ol class="toc"><li><a href="#addition-semantics"><span class="secnum">5.1</span> Runtime Semantics: Evaluation (12.7.3.1)</a></li></ol></li><li><a href="#simd"><span class="secnum">6</span> SIMD</a><ol class="toc"><li><a href="#simd-algorithms"><span class="secnum">6.1</span> Internal algorithms on SIMD types</a><ol class="toc"><li><a href="#simd-create"><span class="secnum">6.1.1</span> SIMDCreate( descriptor, fields )</a></li><li><a href="#simd-to-lane"><span class="secnum">6.1.2</span> SIMDToLane( max, lane )</a></li><li><a href="#simd-abstract-extract-lane"><span class="secnum">6.1.3</span> SIMDExtractLane( value, lane )</a></li><li><a href="#simd-abstract-replace-lane"><span class="secnum">6.1.4</span> SIMDReplaceLane( value, lane, replacement )</a></li><li><a href="#maybe-flush-denormal"><span class="secnum">6.1.5</span> MaybeFlushDenormal( n )</a></li><li><a href="#simd-binary"><span class="secnum">6.1.6</span> SIMDBinaryOp( a, b, op, outputDescriptor )</a></li><li><a href="#simd-unary"><span class="secnum">6.1.7</span> SIMDUnaryOp( a, op [ , flushDenormal ] )</a></li><li><a href="#simd-scalar"><span class="secnum">6.1.8</span> SIMDScalarOp( a, scalar, op )</a></li><li><a href="#simd-load"><span class="secnum">6.1.9</span> SIMDLoad( dataBlock, descriptor, byteOffset [, length] )</a></li><li><a href="#simd-store"><span class="secnum">6.1.10</span> SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )</a></li><li><a href="#simd-reinterpret-cast"><span class="secnum">6.1.11</span> SIMDReinterpretCast( value, newDescriptor )</a></li><li><a href="#simd-int-type"><span class="secnum">6.1.12</span> SIMDBoolType( descriptor )</a></li><li><a href="#simd-relational-op"><span class="secnum">6.1.13</span> SIMDRelationalOp( a, b, op )</a></li></ol></li><li><a href="#simd-constructor"><span class="secnum">6.2</span> <var>SIMD</var>Constructor</a><ol class="toc"><li><a href="#simd-wrapper"><span class="secnum">6.2.1</span> <var>SIMD</var>Constructor( ...values )</a></li><li><a href="#simd-splat"><span class="secnum">6.2.2</span> <var>SIMD</var>Constructor.splat(n)</a></li><li><a href="#simd-check"><span class="secnum">6.2.3</span> <var>SIMD</var>Constructor.check(a)</a></li><li><a href="#simd-add"><span class="secnum">6.2.4</span> <var>SIMD</var>Constructor.add(a, b)</a></li><li><a href="#simd-sub"><span class="secnum">6.2.5</span> <var>SIMD</var>Constructor.sub(a, b)</a></li><li><a href="#simd-mul"><span class="secnum">6.2.6</span> <var>SIMD</var>Constructor.mul(a, b)</a></li><li><a href="#simd-div"><span class="secnum">6.2.7</span> <var>SIMD</var>Constructor.div(a, b)</a></li><li><a href="#simd-max"><span class="secnum">6.2.8</span> <var>SIMD</var>Constructor.max(a, b)</a></li><li><a href="#simd-min"><span class="secnum">6.2.9</span> <var>SIMD</var>Constructor.min(a, b)</a></li><li><a href="#max-num"><span class="secnum">6.2.10</span> MaxNum(n, m)</a></li><li><a href="#simd-max-num"><span class="secnum">6.2.11</span> <var>SIMD</var>Constructor.maxNum(a, b)</a></li><li><a href="#min-num"><span class="secnum">6.2.12</span> MinNum(n, m)</a></li><li><a href="#simd-min-num"><span class="secnum">6.2.13</span> <var>SIMD</var>Constructor.minNum(a, b)</a></li><li><a href="#simd-neg"><span class="secnum">6.2.14</span> <var>SIMD</var>Constructor.neg(a)</a></li><li><a href="#simd-sqrt"><span class="secnum">6.2.15</span> <var>SIMD</var>Constructor.sqrt(a)</a></li><li><a href="#reciprocal"><span class="secnum">6.2.16</span> ReciprocalApproximation(n)</a></li><li><a href="#simd-reciprocal-approximation"><span class="secnum">6.2.17</span> <var>SIMD</var>Constructor.reciprocalApproximation(a, b)</a></li><li><a href="#reciprocal"><span class="secnum">6.2.18</span> ReciprocalSqrtApproximation(n)</a></li><li><a href="#simd-reciprocal-sqrt-approximation"><span class="secnum">6.2.19</span> <var>SIMD</var>Constructor.reciprocalSqrtApproximation(a)</a></li><li><a href="#simd-abs"><span class="secnum">6.2.20</span> <var>SIMD</var>Constructor.abs(a)</a></li><li><a href="#simd-and"><span class="secnum">6.2.21</span> <var>SIMD</var>Constructor.and(a, b)</a></li><li><a href="#simd-xor"><span class="secnum">6.2.22</span> <var>SIMD</var>Constructor.xor(a, b)</a></li><li><a href="#simd-or"><span class="secnum">6.2.23</span> <var>SIMD</var>Constructor.or(a, b)</a></li><li><a href="#simd-not"><span class="secnum">6.2.24</span> <var>SIMD</var>Constructor.not(a)</a></li><li><a href="#simd-less-than"><span class="secnum">6.2.25</span> <var>SIMD</var>Constructor.lessThan(a, b)</a></li><li><a href="#simd-less-than-or-equal"><span class="secnum">6.2.26</span> <var>SIMD</var>Constructor.lessThanOrEqual(a, b)</a></li><li><a href="#simd-greater-than"><span class="secnum">6.2.27</span> <var>SIMD</var>Constructor.greaterThan(a, b)</a></li><li><a href="#simd-greater-than-or-equal"><span class="secnum">6.2.28</span> <var>SIMD</var>Constructor.greaterThanOrEqual(a, b)</a></li><li><a href="#simd-equal"><span class="secnum">6.2.29</span> <var>SIMD</var>Constructor.equal(a, b)</a></li><li><a href="#simd-not-equal"><span class="secnum">6.2.30</span> <var>SIMD</var>Constructor.notEqual(a, b)</a></li><li><a href="#simd-any-true"><span class="secnum">6.2.31</span> <var>SIMD</var>Constructor.anyTrue(a)</a></li><li><a href="#simd-all-true"><span class="secnum">6.2.32</span> <var>SIMD</var>Constructor.allTrue(a)</a></li><li><a href="#simd-select"><span class="secnum">6.2.33</span> <var>SIMD</var>Constructor.select( selector, a, b )</a></li><li><a href="#saturate"><span class="secnum">6.2.34</span> Saturate( descriptor, x )</a></li><li><a href="#add-saturate"><span class="secnum">6.2.35</span> AddSaturate( descriptor )( x, y )</a></li><li><a href="#simd-add-saturate"><span class="secnum">6.2.36</span> <var>SIMD</var>Constructor.addSaturate( a, b )</a></li><li><a href="#sub-saturate"><span class="secnum">6.2.37</span> SubSaturate( descriptor )( x, y )</a></li><li><a href="#simd-sub-saturate"><span class="secnum">6.2.38</span> <var>SIMD</var>Constructor.subSaturate( a, b )</a></li><li><a href="#simd-shift-left-by-scalar"><span class="secnum">6.2.39</span> <var>SIMD</var>Constructor.shiftLeftByScalar( a, bits )</a></li><li><a href="#simd-shift-right-logical-by-scalar"><span class="secnum">6.2.40</span> <var>SIMD</var>Constructor.shiftRightLogicalByScalar( a, bits )</a></li><li><a href="#simd-shift-right-arithmetic-by-scalar"><span class="secnum">6.2.41</span> <var>SIMD</var>Constructor.shiftRightArithmeticByScalar( a, bits )</a></li><li><a href="#simd-horizontal-sum"><span class="secnum">6.2.42</span> <var>SIMD</var>Constructor.horizontalSum( a )</a></li><li><a href="#absolute-difference"><span class="secnum">6.2.43</span> AbsoluteDifference( a, b )</a></li><li><a href="#simd-absolute-difference"><span class="secnum">6.2.44</span> <var>SIMD</var>Constructor.absoluteDifference( a, b )</a></li><li><a href="#simd-widened-absolute-difference"><span class="secnum">6.2.45</span> <var>SIMD</var>Constructor.widenedAbsoluteDifference( a, b )</a></li><li><a href="#simd-extract-lane"><span class="secnum">6.2.46</span> <var>SIMD</var>Constructor.extractLane( simd, lane )</a></li><li><a href="#simd-replace-lane"><span class="secnum">6.2.47</span> <var>SIMD</var>Constructor.replaceLane(simd, lane, value)</a></li><li><a href="#simd-store-function"><span class="secnum">6.2.48</span> <var>SIMD</var>Constructor.store(tarray, index, simd)</a></li><li><a href="#simd-store1"><span class="secnum">6.2.49</span> <var>SIMD</var>Constructor.store1(tarray, index, simd)</a></li><li><a href="#simd-store2"><span class="secnum">6.2.50</span> <var>SIMD</var>Constructor.store2(tarray, index, simd)</a></li><li><a href="#simd-store3"><span class="secnum">6.2.51</span> <var>SIMD</var>Constructor.store3(tarray, index)</a></li><li><a href="#simd-load-function"><span class="secnum">6.2.52</span> <var>SIMD</var>Constructor.load(tarray, index)</a></li><li><a href="#simd-load1"><span class="secnum">6.2.53</span> <var>SIMD</var>Constructor.load1(tarray, index)</a></li><li><a href="#simd-load2"><span class="secnum">6.2.54</span> <var>SIMD</var>Constructor.load2(tarray, index)</a></li><li><a href="#simd-load3"><span class="secnum">6.2.55</span> <var>SIMD</var>Constructor.load3(tarray, index)</a></li><li><a href="#simd-to-timd"><span class="secnum">6.2.56</span> SIMDConstructor.fromTIMDBits( value )</a></li><li><a href="#simd-to-timd-logical"><span class="secnum">6.2.57</span> SIMDConstructor.fromTIMD( value )</a></li><li><a href="#swizzle"><span class="secnum">6.2.58</span> <var>SIMD</var>.swizzle( a, ...lanes )</a></li><li><a href="#shuffle"><span class="secnum">6.2.59</span> <var>SIMD</var>.shuffle( a, b, ...lanes )</a></li></ol></li><li><a href="#simd-proto"><span class="secnum">6.3</span> The <var>SIMD</var>Constructor.prototype</a><ol class="toc"><li><a href="#simd-proto-constructor"><span class="secnum">6.3.1</span> <var>SIMD</var>Constructor.prototype.constructor</a></li><li><a href="#simd-prototype-valueof"><span class="secnum">6.3.2</span> <var>SIMD</var>Constructor.prototype.valueOf()</a></li><li><a href="#simd-prototype-tolocalestring"><span class="secnum">6.3.3</span> <var>SIMD</var>Constructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )</a></li><li><a href="#simd-prototype-tostring"><span class="secnum">6.3.4</span> <var>SIMD</var>Constructor.prototype.toString()</a></li><li><a href="#simd-to-string-tag"><span class="secnum">6.3.5</span> <var>SIMD</var>Constructor.prototype [ @@toStringTag ]</a></li><li><a href="#simd-to-primitive"><span class="secnum">6.3.6</span> <var>SIMD</var>Constructor.prototype [ @@toPrimitive ] ( hint )</a></li></ol></li><li><a href="#simd-descriptors"><span class="secnum">6.4</span> SIMD type descriptors</a><ol class="toc"><li><a href="#simd-float32x4"><span class="secnum">6.4.1</span> Float32x4Descriptor type descriptor</a><ol class="toc"><li><a href="#serialize-float32"><span class="secnum">6.4.1.1</span> SerializeFloat32( block, offset, n, isLittleEndian )</a></li><li><a href="#deserialize-float32"><span class="secnum">6.4.1.2</span> DeserializeFloat32( block, offset, isLittleEndian )</a></li></ol></li><li><a href="#simd-int32x4"><span class="secnum">6.4.2</span> Int32x4Descriptor type descriptor</a><ol class="toc"><li><a href="#serialize-int"><span class="secnum">6.4.2.1</span> SerializeInt( block, offset, n, isLittleEndian, descriptor )</a></li><li><a href="#deserialize-int"><span class="secnum">6.4.2.2</span> DeserializeInt( block, offset, isLittleEndian, descriptor )</a></li><li><a href="#serialize-int32"><span class="secnum">6.4.2.3</span> SerializeInt32( block, offset, n, isLittleEndian )</a></li><li><a href="#deserialize-int32"><span class="secnum">6.4.2.4</span> DeserializeInt32( block, offset, isLittleEndian )</a></li></ol></li><li><a href="#simd-int16x8"><span class="secnum">6.4.3</span> Int16x8Descriptor type descriptor</a><ol class="toc"><li><a href="#serialize-int16"><span class="secnum">6.4.3.1</span> SerializeInt16( block, offset, n, isLittleEndian )</a></li><li><a href="#deserialize-int16"><span class="secnum">6.4.3.2</span> DeserializeInt16( block, offset, isLittleEndian )</a></li></ol></li><li><a href="#simd-int8x16"><span class="secnum">6.4.4</span> Int8x16Descriptor type descriptor</a><ol class="toc"><li><a href="#serialize-int8"><span class="secnum">6.4.4.1</span> SerializeInt8( block, offset, n, isLittleEndian )</a></li><li><a href="#deserialize-int8"><span class="secnum">6.4.4.2</span> DeserializeInt8( block, offset, isLittleEndian )</a></li></ol></li><li><a href="#simd-uint32x4"><span class="secnum">6.4.5</span> Uint32x4Descriptor type descriptor</a><ol class="toc"><li><a href="#serialize-uint32"><span class="secnum">6.4.5.1</span> SerializeUint32( block, offset, n, isLittleEndian )</a></li><li><a href="#deserialize-int32"><span class="secnum">6.4.5.2</span> DeserializeUint32( block, offset, isLittleEndian )</a></li></ol></li><li><a href="#simd-uint16x8"><span class="secnum">6.4.6</span> Uint16x8Descriptor type descriptor</a><ol class="toc"><li><a href="#serialize-uint16"><span class="secnum">6.4.6.1</span> SerializeUint16( block, offset, n, isLittleEndian )</a></li><li><a href="#deserialize-uint16"><span class="secnum">6.4.6.2</span> DeserializeUint16( block, offset, isLittleEndian )</a></li></ol></li><li><a href="#simd-uint8x16"><span class="secnum">6.4.7</span> Uint8x16Descriptor type descriptor</a><ol class="toc"><li><a href="#serialize-uint8"><span class="secnum">6.4.7.1</span> SerializeUint8( block, offset, n, isLittleEndian )</a></li><li><a href="#deserialize-int8"><span class="secnum">6.4.7.2</span> DeserializeInt8( block, offset, isLittleEndian )</a></li></ol></li><li><a href="#simd-bool32x4"><span class="secnum">6.4.8</span> Bool32x4 type descriptor</a></li><li><a href="#simd-bool16x8"><span class="secnum">6.4.9</span> Bool16x8 type descriptor</a></li><li><a href="#simd-bool8x16"><span class="secnum">6.4.10</span> Bool8x16 type descriptor</a></li></ol></li></ol></li></ol></div><emu-intro id="intro">
<h1><span class="secnum"></span>Introduction<span class="utils"><span class="anchor"><a href="#intro">#</a></span></span></h1>
This proposal adds SIMD types and operations to ECMAScript. The proposal adds new primitive types Float32x4, etc, together with wrappers and a definition of their behavior in the language. The current proposal should form a full first draft with all functions and types included.

One problem that this spec aims to solve is to define equality for SIMD values. Before the spec was written, prior implementations used object identity-based equality. However, maintaining object identity puts a big burden on compilers to maintain this identity through operations, where they would rather be able to duplicate and de-duplicate SIMD values arbitrarily based on algebraic identities. By making SIMD values into primitive types with structural equality, compilers are given more freedom.

Ideally, SIMD values will fit into a larger value types proposal. Such a proposal would be a bit more involved, but good work has already been done in that direction. This document describes SIMD without a larger value type system, but it aims to be consistent with how value types might work, and once value types are described in more detail, it will be great to refactor this text by just explaining SIMD in terms of value types. On the other hand, this proposal gives a vehicle to work out some of the issues in value types and can be used as a guide for future value type designs.

This document is organized in terms of where changes would be made to the ES2015 spec. Although ecmarkup generates numbering at the beginning of headers, these won't correspond to the numbering within the existing ECMAScript spec, so I've included a matching numbering in parentheses afterwards, referring to the ES2015 spec.

In this text, <var>SIMD</var> is used to refer to the various SIMD types: Float32x4, Int32x4, Int16x8 Int8x16, Uint32x4, Uint16x8 Uint8x16, Bool32x4, Bool16x8 and Bool8x16. Similarly to Number, <var>SIMD</var> is used to refer to both the type  <em>and</em> the wrapper constructor object. This looks a bit confusing, but it provides the most regularity, as an aim of this specification is to make SIMD types primitives that operate analogously to the existing primitives, rather than a new, exotic sort of thing. To reduce ambiguity, the wrapper constructor is usually referred to as <var>SIMD</var>Constructor, and the type is referred to as <var>SIMD</var>Type. SIMD types are associated with a descriptor spec object, called <var>SIMD</var>Descriptor.

<strong>Please file any issues  <a href="https://github.com/tc39/ecmascript_simd/issues">here</a>!</strong> The authoritative copy of this file is in  <a href="https://github.com/tc39/ecmascript_simd/blob/master/tc39/spec.html">in the simd.js repo</a>; to propose changes to this spec, please send pull requests against that repository. Daniel Ehrenberg (littledan) is responsible for watching for changes to that file, generating the output with ecmarkup and pushing it to  <a href="http://tc39.github.io/ecmascript_simd/">the official rendered location</a>.

Because this document is in spec order, rather than written for direct readability, the logical starting point is actually  <a href="#simd">halfway down</a>.

Related links:

<ul>
<li><a href="https://github.com/nikomatsakis/typed-objects-explainer/blob/master/valuetypes.md">Value types proposal</a></li>
<li><a href="https://github.com/tc39/ecmascript_simd/blob/master/src/ecmascript_simd.js">SIMD polyfill</a></li>
<li><a href="https://github.com/tc39/ecmascript_simd/issues/157">Bug about SIMD.js value semantics</a></li>
</ul>


<ul>
<li>v0.1: Initial proposal based on SIMD values held in Data Blocks</li>
<li>v0.2:
<ul>
<li>SIMD values are explained as Lists of Numbers, and serialized/deserialized only on loads and stores to TypedArrays, and casts.</li>
<li>SIMD values point to a type descriptor, not to the wrapper constructor, which makes cross-realm access more straightforward.</li>
<li>Add all SIMD types, more SIMD operations and all DataView operations.</li>
</ul>
</li>
<li>v0.3: Add more operations, fix some errors and clarify wording.</li>
<li>v0.4: Fix various bugs, mostly reported by rwaldron.</li>
<li>v0.4.1: Refactor definitions for integer types to reduce duplication.</li>
<li>v0.5: Logical and bitwise operations; Int64x2.</li>
<li>v0.5.1: Logical casts between types, like SIMD.float32x4.fromInt32x4; Less exact definition for reciprocalApproximation, reciprocalSqrtApproximation</li>
<li>v0.5.2: Saturating arithmetic; fix mul mis-spec.</li>
<li>v0.5.3: Remove mention of signalling NaN (matches ES6).</li>
<li>v0.5.4: Better formatting for modifications of existing algorithms.</li>
<li>v0.5.5: toLocaleString, shifts, saturating functions only on int16 and smaller, sumOfAbsoluteDifferences. This is the first version to include all functions.</li>
<li>v0.5.6: Fix a few typos, added notes, removed DataView methods, store returns value.</li>
<li>v0.6: Remove Int64x2 and add boolean vectors.</li>
<li>v0.6.1: Relax behavior on subnormals, float to int conversion throws on out of bounds, shift does not mask.</li>
<li>v0.7: Remove Float64x2, Bool64x2, {load,store}[123], selectBits (could be in phase 2); add unsigned operations and sum of absolute differences operations; minor fix in 'shift' definition; clarify what the SIMD object is.</li>
<li>v0.7.1: Add back in {load,store}[123], make ToString() homoiconic.</li>
<li>v0.7.2: Fix shiftRightArithmetic, add @@toPrimitive, do implicit coercion for shift bits.</li>
<li>v0.7.3: Coerce lane arguments, no bitcast on bool, fix typo in .check() and .valueOf(), no constructing wrappers, fix denormal behavior to be deterministic and match hardware, fix shuffle definition, define arithmetic operations only on numeric types, fix up ES2015 links.</li>
<li>v0.8: Separate signed and unsigned integer types</li>
<li>v0.8.1: Minor language fixes and cleanups from review; no behavior changes</li>
<li>v0.8.2: Remove unsignedExtractLane, remove equals, notEquals, swizzle and shuffle from boolean vectors, improve internal algorithm notation, restrict rest argument usage, toString <code>", "</code></li>
<li>v0.8.3: Better explanations and changes based on editor review</li>
</ul>
</emu-intro>

<emu-clause id="terms-and-defs">
<h1><span class="secnum">1</span>Terms and definitions (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values">4.3</a>)<span class="utils"><span class="anchor"><a href="#terms-and-defs">#</a></span></span></h1>

<emu-clause id="primitive-def">
<h1><span class="secnum">1.1</span>primitive value (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-primitive-value">4.3.2</a>)<span class="utils"><span class="anchor"><a href="#primitive-def">#</a></span></span></h1>
member of one of the types Undefined, Null, Boolean, Number, Symbol, or String,  <ins>or one of the SIMD types</ins> as defined in clause 6
</emu-clause>

<emu-clause id="simd-meta-var-def">
<h1><span class="secnum">1.2</span><var>SIMD</var><span class="utils"><span class="anchor"><a href="#simd-meta-var-def">#</a></span></span></h1>
a meta-variable ranging over all SIMD types, namely Float32x4, Int32x4, Int16x8 Int8x16, Uint32x4, Uint16x8, Uint8x16, Bool32x4, Bool16x8 and Bool8x16.
</emu-clause>

<emu-clause id="simd-meta-var-def">
<h1><span class="secnum">1.3</span><var>SIMD</var>Descriptor<span class="utils"><span class="anchor"><a href="#simd-meta-var-def">#</a></span></span></h1>
The  <a href="#simd-descriptors">type descriptor</a> for the particular SIMD type  <a href="#simd-meta-var-def"><var>SIMD</var></a>.
</emu-clause>

<emu-clause id="simd-type-def">
<h1><span class="secnum">1.4</span>SIMD types<span class="utils"><span class="anchor"><a href="#simd-type-def">#</a></span></span></h1>
family of types which each consist of a set of SIMD vector values.
<emu-note><span class="note">Note</span>For example, the Float32x4 type consists of the set of vectors of 4 32-bit floats.</emu-note>
</emu-clause>

<emu-clause id="simd-value-def" aoid="SIMD value">
<h1><span class="secnum">1.5</span>SIMD value<span class="utils"><span class="anchor"><a href="#simd-value-def">#</a></span></span></h1>
Member of a particular SIMD type. These values are represented as described in the  <a href="#simd">SIMD</a> section. SIMD values are primitives, and they are represented as records with two fields.
</emu-clause>

<emu-clause id="simd-object-def" aoid="SIMD object">
<h1><span class="secnum">1.6</span>SIMD object, or SIMD wrapper object<span class="utils"><span class="anchor"><a href="#simd-object-def">#</a></span></span></h1>
For a particular SIMD type, a member of the Object type which has a [[SIMDWrapperData]] internal slot.
</emu-clause>

<emu-clause id="simd-type-descriptor-def">
<h1><span class="secnum">1.7</span>SIMD type descriptor<span class="utils"><span class="anchor"><a href="#simd-type-descriptor-def">#</a></span></span></h1>
A specification-internal record describing the behavior and properties of a SIMD type, described in the %SIMD% section. The meta-variable <var>SIMD</var>Descriptor ranges over type descriptors.
</emu-clause>

<emu-clause id="simd-boolean-type">
<h1><span class="secnum">1.8</span>SIMD boolean type<span class="utils"><span class="anchor"><a href="#simd-boolean-type">#</a></span></span></h1>
A SIMD type whose values are booleans, namely Bool32x4, Bool16x8 and Bool8x16.
</emu-clause>

<emu-clause id="simd-integer-type">
<h1><span class="secnum">1.9</span>SIMD integer type<span class="utils"><span class="anchor"><a href="#simd-integer-type">#</a></span></span></h1>
A SIMD type whose values are booleans, namely Int32x4, Int16x8, Int8x16, Uint32x4, Uint16x8, and Uint8x16.
</emu-clause>

<emu-clause id="simd-floating-point-type">
<h1><span class="secnum">1.10</span>SIMD floating-point type<span class="utils"><span class="anchor"><a href="#simd-floating-point-type">#</a></span></span></h1>
A SIMD type whose values are floating-point numbers, namely Float32x4.
</emu-clause>

<emu-clause id="simd-signed-integer-type">
<h1><span class="secnum">1.11</span>SIMD signed integer type<span class="utils"><span class="anchor"><a href="#simd-signed-integer-type">#</a></span></span></h1>
A SIMD type whose values are signed integers, namely Int32x4, Int16x8 and Int8x16.
</emu-clause>

<emu-clause id="simd-unsigned-integer-type">
<h1><span class="secnum">1.12</span>SIMD unsigned integer type<span class="utils"><span class="anchor"><a href="#simd-unsigned-integer-type">#</a></span></span></h1>
A SIMD type whose values are unsigned integers, namely Uint32x4, Uint16x8, and Uint8x16.
</emu-clause>
</emu-clause>

<emu-clause id="types">
<h1><span class="secnum">2</span>ECMAScript Data Types and Values (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values">6</a>)<span class="utils"><span class="anchor"><a href="#types">#</a></span></span></h1>
<emu-clause id="all-types">
<h1><span class="secnum">2.1</span>ECMAScript language types (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types">6.1</a>)<span class="utils"><span class="anchor"><a href="#all-types">#</a></span></span></h1>
<emu-clause id="object-type">
<h1><span class="secnum">2.1.1</span>The Object Type (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object-type">6.1.7</a>)<span class="utils"><span class="anchor"><a href="#object-type">#</a></span></span></h1>
<emu-clause id="intrinsics">
<h1><span class="secnum">2.1.1.1</span>Well-Known Intrinsic Objects (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-well-known-intrinsic-objects">6.1.7.4</a>)<span class="utils"><span class="anchor"><a href="#intrinsics">#</a></span></span></h1>

<strong>Intrinsic name</strong>: %SIMD%
<br>
<strong>Global name</strong>: <code>SIMD</code>
<br>
<strong>ECMAScript Language Association</strong>: The  <a href="#simd"><code>SIMD</code></a> object

<strong>Intrinsic name</strong>: %<var>SIMD</var>Constructor%
<br>
<strong>Global name</strong>: <code>SIMD.</code><var>SIMD</var> (e.g., <code>SIMD.Float32x4</code>)
<br>
<strong>ECMAScript Language Association</strong>: The  <a href="#simd-constructor"><var>SIMD</var>Constructor</a> constructor

<strong>Intrinsic name</strong>: %<var>SIMD</var>Prototype%
<br>
<strong>Global name</strong>: <code>SIMD.</code><var>SIMD</var><code>.prototype</code> (e.g., <code>SIMD.Float32x4.prototype</code>)
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the prototype data property of  <a href="#simd-constructor">%<var>SIMD</var>Constructor%</a>

<strong>Intrinsic name</strong>: %ArrayPrototype_join%
<br>
<strong>Global name</strong>: <code>Array.prototype.join</code>
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the "join" data property of the intrinsic %ArrayPrototype% object (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.join">ES2015 2.1.3.12</a>)

<strong>Intrinsic name</strong>: %Math_abs%
<br>
<strong>Global name</strong>: <code>Math.abs</code>
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the "abs" data property of the intrinsic %Math% object (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-math.abs">ES2015 20.2.2.1</a>)

<strong>Intrinsic name</strong>: %Math_fround%
<br>
<strong>Global name</strong>: <code>Math.fround</code>
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the "fround" data property of the intrinsic %Math% object (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-math.fround">ES2015 20.2.2.17</a>)

<strong>Intrinsic name</strong>: %Math_max%
<br>
<strong>Global name</strong>: <code>Math.max</code>
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the "max" data property of the intrinsic %Math% object (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-math.max">ES2015 20.2.2.24</a>)

<strong>Intrinsic name</strong>: %Math_min%
<br>
<strong>Global name</strong>: <code>Math.min</code>
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the "min" data property of the intrinsic %Math% object (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-math.min">ES2015 20.2.2.25</a>)

<strong>Intrinsic name</strong>: %Math_sqrt%
<br>
<strong>Global name</strong>: <code>Math.sqrt</code>
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the "max" data property of the intrinsic %Math% object (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-math.sqrt">ES2015 20.2.2.32</a>)

<strong>Intrinsic name</strong>: %Math_imul%
<br>
<strong>Global name</strong>: <code>Math.imul</code>
<br>
<strong>ECMAScript Language Association</strong>: The initial value of the "imul" data property of the intrinsic %Math% object (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-math.imul">ES2015 20.2.2.19</a>)

</emu-clause>
</emu-clause>
</emu-clause>

<emu-clause id="simd-types">
<h1><span class="secnum">2.2</span>SIMD types<span class="utils"><span class="anchor"><a href="#simd-types">#</a></span></span></h1>
<emu-clause id="float32x4" aoid="Float32x4">
<h1><span class="secnum">2.2.1</span>Float32x4<span class="utils"><span class="anchor"><a href="#float32x4">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Float32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-float32x4">Float32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="int32x4" aoid="Int32x4">
<h1><span class="secnum">2.2.2</span>Int32x4<span class="utils"><span class="anchor"><a href="#int32x4">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Int32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-int32x4">Int32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="int16x8" aoid="Int16x8">
<h1><span class="secnum">2.2.3</span>Int16x8<span class="utils"><span class="anchor"><a href="#int16x8">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Int16x8</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-int16x8">Int16x8 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="int8x16" aoid="Int8x16">
<h1><span class="secnum">2.2.4</span>Int8x16<span class="utils"><span class="anchor"><a href="#int8x16">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Int8x16</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-int8x16">Int8x16 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="uint32x4" aoid="Uint32x4">
<h1><span class="secnum">2.2.5</span>Uint32x4<span class="utils"><span class="anchor"><a href="#uint32x4">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Uint32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-uint32x4">Uint32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="uint16x8" aoid="Uint16x8">
<h1><span class="secnum">2.2.6</span>Uint16x8<span class="utils"><span class="anchor"><a href="#uint16x8">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Uint16x8</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-uint16x8">Uint16x8 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="uint8x16" aoid="Uint8x16">
<h1><span class="secnum">2.2.7</span>Uint8x16<span class="utils"><span class="anchor"><a href="#uint8x16">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Uint8x16</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-uint8x16">Uint8x16 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="bool32x4" aoid="Bool32x4">
<h1><span class="secnum">2.2.8</span>Bool32x4<span class="utils"><span class="anchor"><a href="#bool32x4">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Bool32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-bool32x4">Bool32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="bool16x8" aoid="Bool16x8">
<h1><span class="secnum">2.2.9</span>Bool16x8<span class="utils"><span class="anchor"><a href="#bool16x8">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Bool16x8</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-bool16x8">Bool16x8 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="bool8x16" aoid="Bool8x16">
<h1><span class="secnum">2.2.10</span>Bool8x16<span class="utils"><span class="anchor"><a href="#bool8x16">#</a></span></span></h1>

 <a href="#simd-constructor">SIMD.Bool8x16</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-bool8x16">Bool8x16 SIMD type descriptor</a>.

</emu-clause>

</emu-clause>
</emu-clause>

<emu-clause id="abstract-operations">
<h1><span class="secnum">3</span>Abstract Operations (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-operations">7</a>)<span class="utils"><span class="anchor"><a href="#abstract-operations">#</a></span></span></h1>

<emu-clause id="type-conversion">
<h1><span class="secnum">3.1</span>Type Conversion (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-type-conversion">7.1</a>)<span class="utils"><span class="anchor"><a href="#type-conversion">#</a></span></span></h1>

<emu-clause id="to-primitive">
<h1><span class="secnum">3.1.1</span>ToPrimitive ( input [, PreferredType] ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive">7.1.1</a>)<span class="utils"><span class="anchor"><a href="#to-primitive">#</a></span></span></h1>

<strong>Argument type</strong>: <var>SIMD</var>Type
<br>
<strong>Result</strong>: return <var>input</var>
</emu-clause>

<emu-clause id="to-boolean">
<h1><span class="secnum">3.1.2</span>ToBoolean ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toboolean">7.1.2</a>)<span class="utils"><span class="anchor"><a href="#to-boolean">#</a></span></span></h1>

<strong>Argument type</strong>: <var>SIMD</var>Type
<br>
<strong>Result</strong>: return <emu-val>true</emu-val>

<emu-note><span class="note">Note</span>
While it would be possible to make the zero-vector false as a boolean, there are multiple possible interepretations of ToBoolean, and if a programmer is refactoring scalar code, naively keeping in a conditional will lead to a false outcome. Implementation constraints make it expensive to throw on ToBoolean, so returning <emu-val>true</emu-val> (as Objects do) is a nice, neutral answer.
</emu-note>
</emu-clause>

<emu-clause id="to-number">
<h1><span class="secnum">3.1.3</span>ToNumber ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber">7.1.3</a>)<span class="utils"><span class="anchor"><a href="#to-number">#</a></span></span></h1>

<strong>Argument type</strong>: <var>SIMD</var>Type
<br>
<strong>Result</strong>: throw a <emu-val>TypeError</emu-val> exception
</emu-clause>

<emu-clause id="to-string">
<h1><span class="secnum">3.1.4</span>ToString ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-tostring">7.1.12</a>)<span class="utils"><span class="anchor"><a href="#to-string">#</a></span></span></h1>

<strong>Argument type</strong>: <var>SIMD</var>Type
<br>
<strong>Result</strong>:
<emu-alg><ol><li>Let <var>elements</var> be an Array containing the contents of <var>argument</var>.[[SIMDElements]]</li><li>Let <var>t</var> be the string <code>"</code><var>SIMD</var><code>"</code>, e.g., <code>"Float32x4"</code>.</li><li>Let e be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-call-f-v-args">Call</a>(%ArrayPrototype_join%, <var>elements</var>, «", "»).</li><li>Return a new String value computed by concatenating the previous value of "SIMD.", <var>t</var>, "(", <var>e</var>, and ")".</li></ol></emu-alg>

<emu-note><span class="note">Note</span>On a SIMD vector, <code>eval(vector.toString()) == vector</code> in the initial global environment.</emu-note>
</emu-clause>

<emu-clause id="to-object">
<h1><span class="secnum">3.1.5</span>ToObject ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toobject">7.1.13</a>)<span class="utils"><span class="anchor"><a href="#to-object">#</a></span></span></h1>

<strong>Argument type</strong>: <var>SIMD</var>Type
<br>
<strong>Result</strong>: Return a new %<var>SIMD</var>Constructor% wrapper object whose [[SIMDWrapperData]] internal slot is set to <var>argument</var>.
</emu-clause>
</emu-clause>

<emu-clause id="require-object-coercible">
<h1><span class="secnum">3.2</span>RequireObjectCoercible ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-requireobjectcoercible">7.2.1</a>)<span class="utils"><span class="anchor"><a href="#require-object-coercible">#</a></span></span></h1>

<strong>Argument type</strong>: <var>SIMD</var>Type
<br>
<strong>Result</strong>: return <var>argument</var>
</emu-clause>

<emu-clause id="same-value">
<h1><span class="secnum">3.3</span>SameValue(x, y) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-samevalue">7.2.9</a>)<span class="utils"><span class="anchor"><a href="#same-value">#</a></span></span></h1>
<emu-alg><ol><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>x</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>y</var>).</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is different from <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Undefined, return <emu-val>true</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Null, return <emu-val>true</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Number, then<ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is +0 and <var>y</var> is -0, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is -0 and <var>y</var> is +0, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same Number value as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is String, then<ol><li>If <var>x</var> and <var>y</var> are exactly the same sequence of code units (same length and same code units at corresponding indices) return true; otherwise, return false.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Boolean, then<ol><li>If <var>x</var> and <var>y</var> are both true or both false, return true; otherwise, return false.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Symbol, then<ol><li>If <var>x</var> and <var>y</var> are both the same Symbol value, return true; otherwise, return false.</li></ol></li><li><ins>For each SIMD type <var>SIMD</var>Type:</ins><ol><li><ins>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is <var>SIMD</var>Type:</ins><ol><li><ins>Assert <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is <var>SIMD</var>Type.</ins></li><li><ins>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1:</ins><ol><li><ins>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevalue">SameValue</a>(<a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>x</var>, <var>i</var>), <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>y</var>, <var>i</var>)) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</ins></li></ol></li><li><ins>return <emu-val>true</emu-val></ins></li></ol></li></ol></li><li>Return <emu-val>true</emu-val> if <var>x</var> and <var>y</var> are the same Object value. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="same-value-zero">
<h1><span class="secnum">3.4</span>SameValueZero(x, y) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero">7.2.10</a>)<span class="utils"><span class="anchor"><a href="#same-value-zero">#</a></span></span></h1>
Add an extra step at the bottom of the definition of SameValueZero for the new case involving the new type:
<emu-alg><ol><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>x</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>y</var>).</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is different from <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Undefined, return <emu-val>true</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Null, return <emu-val>true</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Number, then<ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is +0 and <var>y</var> is -0, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is -0 and <var>y</var> is +0, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is the same Number value as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is String, then<ol><li>If <var>x</var> and <var>y</var> are exactly the same sequence of code units (same length and same code units at corresponding indices) return true; otherwise, return false.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Boolean, then<ol><li>If <var>x</var> and <var>y</var> are both true or both false, return true; otherwise, return false.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Symbol, then<ol><li>If <var>x</var> and <var>y</var> are both the same Symbol value, return true; otherwise, return false.</li></ol></li><li><ins>For each SIMD type <var>SIMD</var>Type:</ins><ol><li><ins>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is <var>SIMD</var>Type:</ins><ol><li><ins>Assert <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is <var>SIMD</var>Type.</ins></li><li><ins>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1:</ins><ol><li><ins>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-samevaluezero">SameValueZero</a>(<a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>x</var>, <var>i</var>), <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>y</var>, <var>i</var>)) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</ins></li></ol></li><li><ins>return <emu-val>true</emu-val></ins></li></ol></li></ol></li><li>Return <emu-val>true</emu-val> if <var>x</var> and <var>y</var> are the same Object value. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="abstract-relational-comparison">
<h1><span class="secnum">3.5</span>Abstract Relational Comparison (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">7.2.11</a>)<span class="utils"><span class="anchor"><a href="#abstract-relational-comparison">#</a></span></span></h1>
<emu-note><span class="note">Note</span>No changes needed for SIMD; it will throw a TypeError if either operand is a SIMD value because the algorithm will call ToNumber in step 6.a or 6.c, which throws on SIMD values.It is important for Abstract Relational Comparison to throw on SIMD types because there is no clear scalar boolean interpretation, and allowing it to throw makes it possible overload the operator in the future.</emu-note>
</emu-clause>

<emu-clause id="abstract-equality">
<h1><span class="secnum">3.6</span>Abstract Equality Comparison (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison">7.2.12</a>)<span class="utils"><span class="anchor"><a href="#abstract-equality">#</a></span></span></h1>
Replace step 10 with the following:
<emu-alg><ol><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>x</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>y</var>).</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is the same as <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>), then<ol><li>Return the result of performing Strict Equality Comparison x === y.</li></ol></li><li>If x is null and y is undefined, return <emu-val>true</emu-val>.</li><li>If x is undefined and y is null, return <emu-val>true</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Number and <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is String,<br> return the result of the comparison x == <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a>(<var>y</var>).</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is String and <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is Number,<br> return the result of the comparison <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a>(<var>x</var>) == y.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Boolean, return the result of the comparison <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a>(<var>x</var>) == y.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is Boolean, return the result of the comparison x == <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a>(<var>y</var>).</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is either String, Number, <ins>any <var>SIMD</var>Type,</ins> or Symbol and <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is Object, then<br>return the result of the comparison x == <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toprimitive">ToPrimitive</a>(<var>y</var>).</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Object and <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is either String, Number, <ins>any <var>SIMD</var>Type,</ins> or Symbol, then<br>return the result of the comparison <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toprimitive">ToPrimitive</a>(<var>x</var>) == y.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="strict-equality-comparison">
<h1><span class="secnum">3.7</span>Strict Equality Comparison (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison">7.2.13</a>)<span class="utils"><span class="anchor"><a href="#strict-equality-comparison">#</a></span></span></h1>
Add a new step 9, before the existing step 9:
<emu-alg><ol><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>x</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>y</var>).</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is different from <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Undefined, return <emu-val>true</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Null, return <emu-val>true</emu-val>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Number, then<ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same Number value as y, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is +0 and y is −0, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is −0 and y is +0, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is String, then<ol><li>If <var>x</var> and <var>y</var> are exactly the same sequence of code units (same length and same code units at corresponding indices) return true; otherwise, return false.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Boolean, then<ol><li>If <var>x</var> and <var>y</var> are both true or both false, return true; otherwise, return false.</li></ol></li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is Symbol, then<ol><li>If <var>x</var> and <var>y</var> are both the same Symbol value, return true; otherwise, return false.</li></ol></li><li><ins>For each SIMD type <var>SIMD</var>Type:</ins><ol><li><ins>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>x</var>) is <var>SIMD</var>Type:</ins><ol><li><ins>Assert <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>y</var>) is <var>SIMD</var>Type.</ins></li><li><ins>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1:</ins><ol><li><ins>If <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>x</var>, <var>i</var>) === <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>y</var>, <var>i</var>) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</ins></li></ol></li><li><ins>return <emu-val>true</emu-val></ins></li></ol></li></ol></li><li>Return <emu-val>true</emu-val> if <var>x</var> and <var>y</var> are the same Object value. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>
</emu-clause>

<emu-clause id="typeof">
<h1><span class="secnum">4</span>The typeof Operator (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator">12.5.6</a>)<span class="utils"><span class="anchor"><a href="#typeof">#</a></span></span></h1>
<emu-clause id="typeof-evaluation">
<h1><span class="secnum">4.1</span>Runtime Semantics: Evaluation (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation">12.5.6.1</a>)<span class="utils"><span class="anchor"><a href="#typeof-evaluation">#</a></span></span></h1>

<strong>Type of val</strong>: Float32x4
<br>
<strong>Result</strong>: "float32x4"
<br>
<strong>Type of val</strong>: Int32x4
<br>
<strong>Result</strong>: "int32x4"
<br>
<strong>Type of val</strong>: Int16x8
<br>
<strong>Result</strong>: "int16x8"
<br>
<strong>Type of val</strong>: Int8x16
<br>
<strong>Result</strong>: "int8x16"
<br>
<strong>Type of val</strong>: Uint32x4
<br>
<strong>Result</strong>: "uint32x4"
<br>
<strong>Type of val</strong>: Uint16x8
<br>
<strong>Result</strong>: "uint16x8"
<br>
<strong>Type of val</strong>: Uint8x16
<br>
<strong>Result</strong>: "uint8x16"
<br>
<strong>Type of val</strong>: Bool32x4
<br>
<strong>Result</strong>: "bool32x4"
<br>
<strong>Type of val</strong>: Bool16x8
<br>
<strong>Result</strong>: "bool16x8"
<br>
<strong>Type of val</strong>: Bool8x16
<br>
<strong>Result</strong>: "bool8x16"
<emu-note><span class="note">Note</span>This follows the pattern for Number ("number"), Boolean ("boolean"), etc.</emu-note>
</emu-clause>
</emu-clause>

<emu-clause id="addition">
<h1><span class="secnum">5</span>The Addition operator ( + ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-addition-operator-plus">12.7.3</a>)<span class="utils"><span class="anchor"><a href="#addition">#</a></span></span></h1>
<emu-clause id="addition-semantics">
<h1><span class="secnum">5.1</span>Runtime Semantics: Evaluation (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-addition-operator-plus">12.7.3.1</a>)<span class="utils"><span class="anchor"><a href="#addition-semantics">#</a></span></span></h1>
<emu-note><span class="note">Note</span>No changes needed for SIMD. With one SIMD argument and one argument which is a String after ToPrimitive is applied, this will coerce the SIMD value to a string, giving a printed representation like <code>"SIMD.Float32x4(1, 2, 3, 4)"</code>. Otherwise, if either argument is a SIMD value, then ToNumber will be run on step 12. or 14., which would throw a TypeError.It is important for <code>+</code> to throw when applied to SIMD types to allow the future definition of operator overloading on <code>+</code> .</emu-note>
</emu-clause>
</emu-clause>

<emu-clause id="simd" aoid="%SIMD%">
<h1><span class="secnum">6</span>SIMD<span class="utils"><span class="anchor"><a href="#simd">#</a></span></span></h1>



<ul>
<li>[[SIMDTypeDescriptor]], which refers to the wrapper constructor for the type.</li>
<li>[[SIMDElements]], which is a List of values representing the SIMD contents. A list which is in the [[SIMDElements]] of a SIMD value field is never modified.</li>
<emu-note><span class="note">Note 1</span>
In this specification, the [[SIMDElements]] list is modified before putting it in the record, but is not modified once it is in a record for a SIMD value.
</emu-note>
</ul>


<ul>
<li>[[VectorLength]]: The number of elements present in a SIMD value of the type</li>
<li>[[ElementSize]]: Size in bytes of each element</li>
<li>[[CastNumber]]: An internal algorithm for down-casting a Number to the precision representable in the SIMD type</li>
<li>[[SerializeElement]]: An internal algorithm for writing a Number as [[ElementSize]] bytes</li>
<li>[[DeserializeElement]]: An internal algorithm for converting [[ElementSize]] bytes into a Number</li>
<li>[[ElementMax]]: The maximum value included in the range representable by the element type</li>
<li>[[ElementMin]]: The minimum value included in the range representable by the element type</li>
</ul>



<emu-note><span class="note">Note 2</span>Rather than descriptors having fields, this could be specified by a table analogous to Table 49 in the ES6 description for TypedArrays. However, the author finds it easier to express this purely in terms of records. TypedArrays could be specified like this too, and share some infrastructure with SIMD, but in their current form, it seems difficult to generalize them to SIMD directly.</emu-note>
<emu-note><span class="note">Note 3</span>CastNumber converts elements to Numbers; however, for most SIMD types, it will convert them to a restricted range of Number. In a real implementation, the numbers would likely be represented in a more compact form. However, the internal representation is not observable.</emu-note>

<a href="#simd-object-def">SIMD wrappers</a> are objects whose [[Prototype]] is a <var>SIMD</var>Constructor and which have a [[SIMDWrapperData]] internal slot. They can be created by calling <code>ToObject</code> on a SIMD value.

<emu-clause id="simd-algorithms">
<h1><span class="secnum">6.1</span>Internal algorithms on SIMD types<span class="utils"><span class="anchor"><a href="#simd-algorithms">#</a></span></span></h1>

<emu-clause id="simd-create" aoid="SIMDCreate">
<h1><span class="secnum">6.1.1</span>SIMDCreate( descriptor, fields )<span class="utils"><span class="anchor"><a href="#simd-create">#</a></span></span></h1>
<emu-alg><ol><li>Assert: The length of <var>fields</var> = <var>descriptor</var>.[[VectorLength]].</li><li>Let <var>list</var> be a new List of length <var>descriptor</var>.[[VectorLength]].</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>n</var> be <var>descriptor</var>.[[CastNumber]](fields[<var>i</var>]).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>n</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>n</var>.</li></ol></li><li>Return the SIMD value specified by the record { [[SIMDTypeDescriptor]]: <var>descriptor</var>, [[SIMDElements]]: <var>list</var> }.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-to-lane" aoid="SIMDToLane">
<h1><span class="secnum">6.1.2</span>SIMDToLane( max, lane )<span class="utils"><span class="anchor"><a href="#simd-to-lane">#</a></span></span></h1>
<emu-alg><ol><li>Let <var>index</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber">ToNumber</a>(<var>lane</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>index</var>).</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>) or <var>index</var> &lt; 0 or <var>index</var> ≥ <var>max</var>, throw a RangeError.</li><li>Return <var>index</var></li></ol></emu-alg>
<emu-note><span class="note">Note</span>While this single definition doesn't explicitly refer to the SIMD type in indexing the list, an implementation may use different representations for the Number elements on different types and generate different code for the accesses.</emu-note>
</emu-clause>

<emu-clause id="simd-abstract-extract-lane" aoid="SIMDExtractLane">
<h1><span class="secnum">6.1.3</span>SIMDExtractLane( value, lane )<span class="utils"><span class="anchor"><a href="#simd-abstract-extract-lane">#</a></span></span></h1>
<emu-alg><ol><li>Assert: <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>value</var>) is a <var>SIMD</var>Type.</li><li>Let <var>index</var> be <a href="#simd-to-lane">SIMDToLane</a>(<var>value</var>.[[SIMDTypeDescriptor]].[[VectorLength]], <var>lane</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>index</var>).</li><li>Return <var>value</var>.[[SIMDElements]][<var>index</var>]</li></ol></emu-alg>
<emu-note><span class="note">Note</span>While this single definition doesn't explicitly refer to the SIMD type in indexing the list, an implementation may use different representations for the Number elements on different types and generate different code for the accesses.</emu-note>
</emu-clause>

<emu-clause id="simd-abstract-replace-lane" aoid="SIMDReplaceLane">
<h1><span class="secnum">6.1.4</span>SIMDReplaceLane( value, lane, replacement )<span class="utils"><span class="anchor"><a href="#simd-abstract-replace-lane">#</a></span></span></h1>
<emu-alg><ol><li>Assert: <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>value</var>) is a <var>SIMD</var>Type.</li><li>Let <var>descriptor</var> be <var>value</var>.[[SIMDTypeDescriptor]].</li><li>Let <var>index</var> be <a href="#simd-to-lane">SIMDToLane</a>(<var>descriptor</var>.[[VectorLength]], <var>lane</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>index</var>).</li><li>Let <var>list</var> be a copy of <var>value</var>.[[SIMDElements]].</li><li>Set <var>list</var>[<var>index</var>] to <var>replacement</var>.</li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>descriptor</var>, <var>list</var>).</li></ol></emu-alg>
<emu-note><span class="note">Note</span>While this single definition doesn't explicitly refer to the SIMD type in indexing the list, an implementation may use different representations for the Number elements on different types and generate different code for the accesses.</emu-note>
</emu-clause>

<emu-clause id="maybe-flush-denormal" aoid="MaybeFlushDenormal">
<h1><span class="secnum">6.1.5</span>MaybeFlushDenormal( n )<span class="utils"><span class="anchor"><a href="#maybe-flush-denormal">#</a></span></span></h1>



<emu-alg><ol><li>Return <var>n</var>.</li></ol></emu-alg>
The second option:
<emu-alg><ol><li>If <var>n</var> is a subnormal floating point number,<ol><li>If <var>n</var> &gt; 0, return +0.</li><li>Otherwise, return -0.</li></ol></li><li>Otherwise, return <var>n</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-binary" aoid="SIMDBinaryOp">
<h1><span class="secnum">6.1.6</span>SIMDBinaryOp( a, b, op, outputDescriptor )<span class="utils"><span class="anchor"><a href="#simd-binary">#</a></span></span></h1>
<emu-alg><ol><li>Assert: <var>a</var>.[[SIMDTypeDescriptor]] is <var>b</var>.[[SIMDTypeDescriptor]]</li><li>Let <var>descriptor</var> be <var>a</var>.[[SIMDTypeDescriptor]].</li><li>If <var>outputDescriptor</var> is not provided, let <var>outputDescriptor</var> be <var>descriptor</var>.</li><li>Let <var>list</var> be a new List of length <var>descriptor</var>.[[VectorLength]].</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>ax</var> = <a href="#maybe-flush-denormal">MaybeFlushDenormal</a>(<a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>a</var>, <var>i</var>)).</li><li>Let <var>bx</var> = <a href="#maybe-flush-denormal">MaybeFlushDenormal</a>(<a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>b</var>, <var>i</var>)).</li><li>Let <var>res</var> = <a href="#maybe-flush-denormal">MaybeFlushDenormal</a>(op(<var>ax</var>, <var>bx</var>)).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>res</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>res</var>.</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>outputDescriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-unary" aoid="SIMDUnaryOp">
<h1><span class="secnum">6.1.7</span>SIMDUnaryOp( a, op [ , flushDenormal ] )<span class="utils"><span class="anchor"><a href="#simd-unary">#</a></span></span></h1>
<emu-alg><ol><li>Let <var>descriptor</var> be <var>a</var>.[[SIMDTypeDescriptor]].</li><li>If <var>flushDenormal</var> is not provided, let <var>flushDenormal</var>true be <emu-val>true</emu-val>.</li><li>Let <var>list</var> be a new List of length <var>descriptor</var>.[[VectorLength]].</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>block</var>).</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>ax</var> = <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>a</var>, <var>i</var>).</li><li>If <var>flushDenormal</var>, let <var>ax</var> be <a href="#maybe-flush-denormal">MaybeFlushDenormal</a>(<var>ax</var>).</li><li>Let <var>res</var> = op(<var>ax</var>).</li><li>If <var>flushDenormal</var>, let <var>res</var> be <a href="#maybe-flush-denormal">MaybeFlushDenormal</a>(<var>res</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>res</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>res</var>.</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>descriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-scalar" aoid="SIMDScalarOp">
<h1><span class="secnum">6.1.8</span>SIMDScalarOp( a, scalar, op )<span class="utils"><span class="anchor"><a href="#simd-scalar">#</a></span></span></h1>
<emu-alg><ol><li>Let <var>descriptor</var> be <var>a</var>.[[SIMDTypeDescriptor]].</li><li>Let <var>list</var> be a new List of length <var>descriptor</var>.[[VectorLength]].</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>block</var>).</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>ax</var> = <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>a</var>, <var>i</var>).</li><li>Let <var>res</var> = op(<var>ax</var>, <var>scalar</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>res</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>res</var>.</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>descriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load" aoid="SIMDLoad">
<h1><span class="secnum">6.1.9</span>SIMDLoad( dataBlock, descriptor, byteOffset [, length] )<span class="utils"><span class="anchor"><a href="#simd-load">#</a></span></span></h1>
<emu-alg><ol><li>Assert: <var>dataBlock</var> is a Data Block, <var>descriptor</var> is a SIMD type descriptor</li><li>If <var>length</var> is not provided, let <var>length</var> be <var>descriptor</var>.[[VectorLength]]. Otherwise, assert <var>length</var> ≤ <var>descriptor</var>.[[VectorLength]].</li><li>Assert: <var>byteOffset</var> is an integer greater than or equal to zero, and less than or equal to the size of <var>dataBlock</var> - <var>descriptor</var>.[[ElementSize]] × <var>length</var>.</li><li>Let <var>list</var> be a List of length <var>descriptor</var>.[[VectorLength]], initialized to all 0.</li><li>For <var>i</var> from 0 to <var>length</var> - 1,<ol><li>Set <var>list</var>[<var>i</var>] to <var>descriptor</var>.[[DeserializeElement]](<var>dataBlock</var>, <var>byteOffset</var>).</li></ol></li><li>Return the record { [[SIMDTypeDescriptor]]: <var>descriptor</var>, [[SIMDElements]]: <var>list</var> }.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store" aoid="SIMDStore">
<h1><span class="secnum">6.1.10</span>SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )<span class="utils"><span class="anchor"><a href="#simd-store">#</a></span></span></h1>
<emu-alg><ol><li>Assert: <var>dataBlock</var> is a Data Block, <var>descriptor</var> is a SIMD type descriptor</li><li>If <var>length</var> is not provided, let <var>length</var> be <var>descriptor</var>.[[VectorLength]]. Otherwise, assert <var>length</var> ≤ <var>descriptor</var>.[[VectorLength]].</li><li>Assert: <var>byteOffset</var> is an integer greater than or equal to zero, and less than or equal to the size of <var>dataBlock</var> - <var>descriptor</var>.[[ElementSize]] × <var>length</var>.</li><li>For <var>i</var> from 0 to <var>length</var> - 1,<ol><li><var>descriptor</var>.[[SerializeElement]](<var>dataBlock</var>, <var>byteOffset</var> + <var>i</var> × <var>descriptor</var>.[[ElementSize]], <var>n</var>.[[SIMDElements]][<var>i</var>]).</li></ol></li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-reinterpret-cast" aoid="SIMDReinterpretCast">
<h1><span class="secnum">6.1.11</span>SIMDReinterpretCast( value, newDescriptor )<span class="utils"><span class="anchor"><a href="#simd-reinterpret-cast">#</a></span></span></h1>
<emu-note><span class="note">Note</span>This is used to define operations like SIMD.Float32x4.fromInt8x16Bits.</emu-note>
<emu-alg><ol><li>Assert: <var>value</var>.[[SIMDTypeDescriptor]].[[VectorLength]] × <var>value</var>.[[SIMDTypeDescriptor]].[[ElementSize]] = <var>newDescriptor</var>.[[VectorLength]] × <var>newDescriptor</var>.[[ElementSize]].</li><li>Let <var>bytes</var> be <var>newDescriptor</var>.[[VectorLength]] × <var>newDescriptor</var>.[[ElementSize]].</li><li>Let <var>block</var> be the result of <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-createbytedatablock">CreateByteDataBlock</a>(<var>bytes</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>block</var>).</li><li><a href="#simd-store">SIMDStore</a>(<var>block</var>, <var>value</var>, 0).</li><li>Return <a href="#simd-load">SIMDLoad</a>(<var>block</var>, <var>newDescriptor</var>, 0).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-int-type" aoid="SIMDBoolType">
<h1><span class="secnum">6.1.12</span>SIMDBoolType( descriptor )<span class="utils"><span class="anchor"><a href="#simd-int-type">#</a></span></span></h1>
<emu-alg><ol><li>Assert: <var>descriptor</var>.[[VectorLength]] × _descriptor.[[ElementSize]] = 128. Otherwise, in a future extension to the spec, different boolean descriptors will be returned.</li><li>Let <var>length</var> be <var>descriptor</var>.[[VectorLength]].</li><li>If <var>length</var> = 4, return Bool32x4Descriptor.</li><li>If <var>length</var> = 8, return Bool16x8Descriptor.</li><li>Assert <var>length</var> = 16.</li><li>Return Bool8x16Descriptor.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-relational-op" aoid="SIMDRelationalOp">
<h1><span class="secnum">6.1.13</span>SIMDRelationalOp( a, b, op )<span class="utils"><span class="anchor"><a href="#simd-relational-op">#</a></span></span></h1>
<emu-alg><ol><li>Let <var>outputDescriptor</var> be <a href="#simd-int-type">SIMDBoolType</a>(<var>a</var>.[[SIMDTypeDescriptor]]).</li><li>Return <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <var>op</var>, <var>outputDescriptor</var>).</li></ol></emu-alg>
</emu-clause>

</emu-clause>

<emu-clause id="simd-constructor">
<h1><span class="secnum">6.2</span><var>SIMD</var>Constructor<span class="utils"><span class="anchor"><a href="#simd-constructor">#</a></span></span></h1>



<emu-clause id="simd-wrapper">
<h1><span class="secnum">6.2.1</span><var>SIMD</var>Constructor( ...values )<span class="utils"><span class="anchor"><a href="#simd-wrapper">#</a></span></span></h1>
<emu-note><span class="note">Note</span>SIMD wrapped objects cannot be created using <code>new</code> on <var>SIMD</var>Constructor; they can be created explicitly with <code>Object()</code> however.</emu-note>
<emu-alg><ol><li>If <emu-val>NewTarget</emu-val> is not undefined, throw a <emu-val>TypeError</emu-val>.</li><li>Let <var>fields</var> be a new List.</li><li>For integer <var>n</var> from <emu-val>0</emu-val> to <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Append <var>values</var>[<var>n</var>] to the end of <var>fields</var>, or <emu-val>undefined</emu-val> if there were not enough arguments.</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>fields</var>).</li></ol></emu-alg>
The <code>length</code> property of <code>_SIMD_Constructor</code> is <var>SIMD</var>Descriptor.[[VectorLength]].
</emu-clause>



<emu-clause id="simd-splat">
<h1><span class="secnum">6.2.2</span><var>SIMD</var>Constructor.splat(n)<span class="utils"><span class="anchor"><a href="#simd-splat">#</a></span></span></h1>
<emu-alg><ol><li>Let <var>list</var> be a new List of length <var>SIMD</var>Descriptor.[[VectorLength]], with all entries filled with <var>n</var>.</li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-check">
<h1><span class="secnum">6.2.3</span><var>SIMD</var>Constructor.check(a)<span class="utils"><span class="anchor"><a href="#simd-check">#</a></span></span></h1>
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val>.</li><li>Return <var>a</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-add">
<h1><span class="secnum">6.2.4</span><var>SIMD</var>Constructor.add(a, b)<span class="utils"><span class="anchor"><a href="#simd-add">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-addition-operator-plus">ES2015 12.7.3 (The Addition operator ( + ))</a>.

This operation is only defined on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <code>+</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-sub">
<h1><span class="secnum">6.2.5</span><var>SIMD</var>Constructor.sub(a, b)<span class="utils"><span class="anchor"><a href="#simd-sub">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-subtraction-operator-minus">ES2015 12.7.4 (The Subtraction operator ( - ))</a>.

This operation is only defined on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <code>-</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-mul">
<h1><span class="secnum">6.2.6</span><var>SIMD</var>Constructor.mul(a, b)<span class="utils"><span class="anchor"><a href="#simd-mul">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-mul-operator">ES2015 12.6.3.1 (Applying the * Operator)</a>.

This operation is only defined on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>If <var>SIMD</var>Type is an integer SIMD type, let <var>op</var> be %Math_imul%; otherwise, <var>SIMD</var>Type is a floating point SIMD type, and let <var>op</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-mul-operator"><code>*</code></a>.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <var>op</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-div">
<h1><span class="secnum">6.2.7</span><var>SIMD</var>Constructor.div(a, b)<span class="utils"><span class="anchor"><a href="#simd-div">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-div-operator">ES2015 12.6.3.2 (Applying the / Operator)</a>.

This function is defined only on floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-div-operator"><code>/</code></a>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-max">
<h1><span class="secnum">6.2.8</span><var>SIMD</var>Constructor.max(a, b)<span class="utils"><span class="anchor"><a href="#simd-max">#</a></span></span></h1>
This property is defined only on floating point SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, %Math_max%).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-min">
This property is defined only on floating point SIMD types.
<h1><span class="secnum">6.2.9</span><var>SIMD</var>Constructor.min(a, b)<span class="utils"><span class="anchor"><a href="#simd-min">#</a></span></span></h1>
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, %Math_min%).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="max-num" aoid="MaxNum">
<h1><span class="secnum">6.2.10</span>MaxNum(n, m)<span class="utils"><span class="anchor"><a href="#max-num">#</a></span></span></h1>
<emu-alg><ol><li>Assert <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>n</var>) is Number and <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>m</var>) is Number.</li><li>If <var>n</var> is <emu-val>NaN</emu-val>, return <var>m</var>.</li><li>If <var>m</var> is <emu-val>NaN</emu-val>, return <var>n</var>.</li><li>Let <var>result</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-call-f-v-args">Call</a>(%Math_max%, %Math%, «<var>n</var>, <var>m</var>»).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-max-num">
<h1><span class="secnum">6.2.11</span><var>SIMD</var>Constructor.maxNum(a, b)<span class="utils"><span class="anchor"><a href="#simd-max-num">#</a></span></span></h1>
This property is defined only on floating point SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, MaxNum).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="min-num" aoid="MinNum">
<h1><span class="secnum">6.2.12</span>MinNum(n, m)<span class="utils"><span class="anchor"><a href="#min-num">#</a></span></span></h1>
<emu-alg><ol><li>Assert <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>n</var>) is Number and <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>m</var>) is Number.</li><li>If <var>n</var> is <emu-val>NaN</emu-val>, return <var>m</var>.</li><li>If <var>m</var> is <emu-val>NaN</emu-val>, return <var>n</var>.</li><li>Let <var>result</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-call-f-v-args">Call</a>(%Math_min%, %Math%, «<var>n</var>, <var>m</var>»).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-min-num">
<h1><span class="secnum">6.2.13</span><var>SIMD</var>Constructor.minNum(a, b)<span class="utils"><span class="anchor"><a href="#simd-min-num">#</a></span></span></h1>
This property is defined only on floating point SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, MinNum).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-neg">
<h1><span class="secnum">6.2.14</span><var>SIMD</var>Constructor.neg(a)<span class="utils"><span class="anchor"><a href="#simd-neg">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-unary-minus-operator">ES2015 12.5.10 (Unary - Operator)</a>.

This operation is only defined on signed integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-unary">SIMDUnaryOp</a>(<var>a</var>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-unary-minus-operator"><code>-</code></a>, <emu-val>false</emu-val>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-sqrt">
<h1><span class="secnum">6.2.15</span><var>SIMD</var>Constructor.sqrt(a)<span class="utils"><span class="anchor"><a href="#simd-sqrt">#</a></span></span></h1>
This property is defined only on floating point SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-unary">SIMDUnaryOp</a>(<var>a</var>, %Math_sqrt%).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="reciprocal" aoid="ReciprocalApproximation">
<h1><span class="secnum">6.2.16</span>ReciprocalApproximation(n)<span class="utils"><span class="anchor"><a href="#reciprocal">#</a></span></span></h1>
Returns an implementation-dependent approximation to the reciprocal of <var>n</var>.
<ul>
<li>If <var>n</var> is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.</li>
<li>If <var>n</var> is +0, the result is +∞.</li>
<li>If <var>n</var> is -0, the result is -∞.</li>
<li>If <var>n</var> is +∞, the result is +0.</li>
<li>If <var>n</var> is -∞, the result is -0.</li>
</ul>
</emu-clause>

<emu-clause id="simd-reciprocal-approximation">
<h1><span class="secnum">6.2.17</span><var>SIMD</var>Constructor.reciprocalApproximation(a, b)<span class="utils"><span class="anchor"><a href="#simd-reciprocal-approximation">#</a></span></span></h1>
This property is defined only on floating point SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-unary">SIMDUnaryOp</a>(<var>a</var>, ReciprocalApproximation).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="reciprocal" aoid="ReciprocalSqrtApproximation">
<h1><span class="secnum">6.2.18</span>ReciprocalSqrtApproximation(n)<span class="utils"><span class="anchor"><a href="#reciprocal">#</a></span></span></h1>
Returns an implementation-dependent approximation to the reciprocal of the square root of <var>n</var>.
<ul>
<li>If <var>n</var> is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.</li>
<li>If <var>n</var> is +0, the result is +∞.</li>
<li>If <var>n</var> is -0, the result is -∞.</li>
<li>If <var>n</var> is +∞, the result is +0.</li>
<li>If <var>n</var> is less than 0, the result is <emu-val>NaN</emu-val>.</li>
</ul>
</emu-clause>

<emu-clause id="simd-reciprocal-sqrt-approximation">
<h1><span class="secnum">6.2.19</span><var>SIMD</var>Constructor.reciprocalSqrtApproximation(a)<span class="utils"><span class="anchor"><a href="#simd-reciprocal-sqrt-approximation">#</a></span></span></h1>
This property is defined only on floating point SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-unary">SIMDUnaryOp</a>(<var>a</var>, ReciprocalSqrtApproximation).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-abs">
<h1><span class="secnum">6.2.20</span><var>SIMD</var>Constructor.abs(a)<span class="utils"><span class="anchor"><a href="#simd-abs">#</a></span></span></h1>
This operation exists only on floating point SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-unary">SIMDUnaryOp</a>(<var>a</var>, %Math_abs%, <emu-val>false</emu-val>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-and">
<h1><span class="secnum">6.2.21</span><var>SIMD</var>Constructor.and(a, b)<span class="utils"><span class="anchor"><a href="#simd-and">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-binary-bitwise-operators">ES2015 12.11 (Binary Bitwise Operators)</a>.

This operation exists only on integer and boolean SIMD types.

<emu-note><span class="note">Note</span>On boolean types, this could have been specified as using &amp;&amp; rather than &amp;. However, the behavior is the same, as <code>ToBoolean(x&amp;y)</code> is the same as <code>x &amp;&amp; y</code> for boolean <code>x</code> and <code>y</code>. The same goes for <code>or</code> below.</emu-note>
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <code>&amp;</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-xor">
<h1><span class="secnum">6.2.22</span><var>SIMD</var>Constructor.xor(a, b)<span class="utils"><span class="anchor"><a href="#simd-xor">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-binary-bitwise-operators">ES2015 12.11 (Binary Bitwise Operators)</a>.

This operation exists only on integer and boolean SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <code>^</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-or">
<h1><span class="secnum">6.2.23</span><var>SIMD</var>Constructor.or(a, b)<span class="utils"><span class="anchor"><a href="#simd-or">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-binary-bitwise-operators">ES2015 12.11 (Binary Bitwise Operators)</a>.

This operation exists only on integer and boolean SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <code>|</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-not">
<h1><span class="secnum">6.2.24</span><var>SIMD</var>Constructor.not(a)<span class="utils"><span class="anchor"><a href="#simd-not">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-bitwise-not-operator">ES2015 12.5.11</a> (Bitwise NOT Operator ( ~ )).

This operation exists only on integer and boolean SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-unary">SIMDUnaryOp</a>(<var>a</var>, <code>~</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-less-than">
<h1><span class="secnum">6.2.25</span><var>SIMD</var>Constructor.lessThan(a, b)<span class="utils"><span class="anchor"><a href="#simd-less-than">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.

This operation exists only on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-relational-op">SIMDRelationalOp</a>(<var>a</var>, <var>b</var>, <code>&lt;</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>Due to the definition of SIMDRelationalOp, denormals will perform in this function as if they are equal to each other on some platforms, but not others.</emu-note>
</emu-clause>

<emu-clause id="simd-less-than-or-equal">
<h1><span class="secnum">6.2.26</span><var>SIMD</var>Constructor.lessThanOrEqual(a, b)<span class="utils"><span class="anchor"><a href="#simd-less-than-or-equal">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.

This operation exists only on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-relational-op">SIMDRelationalOp</a>(<var>a</var>, <var>b</var>, <code>&lt;=</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-greater-than">
<h1><span class="secnum">6.2.27</span><var>SIMD</var>Constructor.greaterThan(a, b)<span class="utils"><span class="anchor"><a href="#simd-greater-than">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.

This operation exists only on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-relational-op">SIMDRelationalOp</a>(<var>a</var>, <var>b</var>, <code>&gt;</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-greater-than-or-equal">
<h1><span class="secnum">6.2.28</span><var>SIMD</var>Constructor.greaterThanOrEqual(a, b)<span class="utils"><span class="anchor"><a href="#simd-greater-than-or-equal">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.

This operation exists only on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-relational-op">SIMDRelationalOp</a>(<var>a</var>, <var>b</var>, <code>&gt;=</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-equal">
<h1><span class="secnum">6.2.29</span><var>SIMD</var>Constructor.equal(a, b)<span class="utils"><span class="anchor"><a href="#simd-equal">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison">ES2015 7.2.13 (Strict Equality Comparison)</a>.

This operation exists only on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-relational-op">SIMDRelationalOp</a>(<var>a</var>, <var>b</var>, <code>===</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>The resulting notion of equality is weaker than <code>===</code> on some platforms because denormals may be flushed to 0.</emu-note>
</emu-clause>

<emu-clause id="simd-not-equal">
<h1><span class="secnum">6.2.30</span><var>SIMD</var>Constructor.notEqual(a, b)<span class="utils"><span class="anchor"><a href="#simd-not-equal">#</a></span></span></h1>

 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison">ES2015 7.2.13 (Strict Equality Comparison)</a>.

This operation exists only on integer and floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-relational-op">SIMDRelationalOp</a>(<var>a</var>, <var>b</var>, <code>!==</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>The resulting notion of equality is weaker than === on some platforms because denormals may be flushed to 0.</emu-note>
</emu-clause>

<emu-clause id="simd-any-true">
<h1><span class="secnum">6.2.31</span><var>SIMD</var>Constructor.anyTrue(a)<span class="utils"><span class="anchor"><a href="#simd-any-true">#</a></span></span></h1>
This is defined on boolean SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>If <var>a</var>.[[SIMDElements]][<var>i</var>] is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li></ol></li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-all-true">
<h1><span class="secnum">6.2.32</span><var>SIMD</var>Constructor.allTrue(a)<span class="utils"><span class="anchor"><a href="#simd-all-true">#</a></span></span></h1>
This is defined on boolean SIMD types.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>If <var>a</var>.[[SIMDElements]][<var>i</var>] is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</li></ol></li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-select">
<h1><span class="secnum">6.2.33</span><var>SIMD</var>Constructor.select( selector, a, b )<span class="utils"><span class="anchor"><a href="#simd-select">#</a></span></span></h1>



<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>outputDescriptor</var> be <a href="#simd-int-type">SIMDBoolType</a>(<var>SIMD</var>Descriptor).</li><li>If <var>selector</var>.[[SIMDTypeDescriptor]] is not <var>outputDescriptor</var>, throw a TypeError.</li><li>Let <var>list</var> be a new List.</li><li>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>If <var>sector</var>.[[SIMDElements]][<var>i</var>] is <emu-val>true</emu-val>, let <var>list</var>[<var>i</var>] be <var>a</var>.[[SIMDElements]][<var>i</var>].</li><li>Otherwise, let <var>list</var>[<var>i</var>] be <var>b</var>.[[SIMDElements]][<var>i</var>].</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="saturate" aoid="Saturate">
<h1><span class="secnum">6.2.34</span>Saturate( descriptor, x )<span class="utils"><span class="anchor"><a href="#saturate">#</a></span></span></h1>
<emu-alg><ol><li>If <var>x</var> &gt; <var>descriptor</var>.[[ElementMax]], return <var>descriptor</var>.[[ElementMax]].</li><li>Otherwise, if <var>x</var> &lt; <var>descriptor</var>.[[ElementMin]], return <var>descriptor</var>.[[ElementMin]]</li><li>Return <var>x</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="add-saturate" aoid="AddSaturate">
<h1><span class="secnum">6.2.35</span>AddSaturate( descriptor )( x, y )<span class="utils"><span class="anchor"><a href="#add-saturate">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#saturate">Saturate</a>(<var>descriptor</var>, <var>x</var> + <var>y</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-add-saturate">
<h1><span class="secnum">6.2.36</span><var>SIMD</var>Constructor.addSaturate( a, b )<span class="utils"><span class="anchor"><a href="#simd-add-saturate">#</a></span></span></h1>
This operation is only defined on integer SIMD types whose <var>SIMD</var>Descriptor.[[ElementSize]] ≤ 2.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <a href="#add-saturate">AddSaturate</a>(<var>a</var>.[[SIMDTypeDescriptor]])).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>This operation is not defined on Uint32x4 and Int32x4 because it is not accelerated by current hardware on those types.</emu-note>
</emu-clause>

<emu-clause id="sub-saturate" aoid="SubSaturate">
<h1><span class="secnum">6.2.37</span>SubSaturate( descriptor )( x, y )<span class="utils"><span class="anchor"><a href="#sub-saturate">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#saturate">Saturate</a>(<var>descriptor</var>, <var>x</var> - <var>y</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-sub-saturate">
<h1><span class="secnum">6.2.38</span><var>SIMD</var>Constructor.subSaturate( a, b )<span class="utils"><span class="anchor"><a href="#simd-sub-saturate">#</a></span></span></h1>
This operation is only defined on integer SIMD types whose <var>SIMD</var>Descriptor.[[ElementSize]] ≤ 2.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, <a href="#sub-saturate">SubSaturate</a>(<var>a</var>.[[SIMDTypeDescriptor]])).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>This operation is not defined on Uint32x4 and Int32x4 because it is not accelerated by current hardware on those types.</emu-note>
</emu-clause>

<emu-clause id="simd-shift-left-by-scalar">
<h1><span class="secnum">6.2.39</span><var>SIMD</var>Constructor.shiftLeftByScalar( a, bits )<span class="utils"><span class="anchor"><a href="#simd-shift-left-by-scalar">#</a></span></span></h1>
This operation is only defined on integer SIMD types. This definition uses the refers to <code>&lt;&lt;</code> as defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-left-shift-operator">ES2015 12.8.3 (The Left Shift Operator ( &lt;&lt; ))</a>.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>scalar</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-touint32">ToUint32</a>(<var>bits</var>).</li><li>If <var>scalar</var> ≥ <var>SIMD</var>Descriptor.[[ElementSize]] × 8, then<ol><li>Let <var>list</var> be a list of length <var>SIMD</var>Descriptor.[[VectorLength]], filled with 0.</li><li>return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></li><li>Let <var>result</var> be <a href="#simd-scalar">SIMDScalarOp</a>(<var>a</var>, <var>scalar</var>, <code>&lt;&lt;</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>Unlike ECMAScript scalar shift, there is no "wrap-around" behavior.</emu-note>
</emu-clause>

<emu-clause id="simd-shift-right-logical-by-scalar">
<h1><span class="secnum">6.2.40</span><var>SIMD</var>Constructor.shiftRightLogicalByScalar( a, bits )<span class="utils"><span class="anchor"><a href="#simd-shift-right-logical-by-scalar">#</a></span></span></h1>
This operation is only defined on signed integer SIMD types. This definition uses the refers to <code>&gt;&gt;&gt;</code> as defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-unsigned-right-shift-operator">ES2015 12.8.5 (The Unsigned Right Shift Operator ( &gt;&gt;&gt; ))</a>.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>scalar</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-touint32">ToUint32</a>(<var>bits</var>).</li><li>If <var>scalar</var> ≥ <var>SIMD</var>Descriptor.[[ElementSize]] × 8, then<ol><li>Let <var>list</var> be a list of length <var>SIMD</var>Descriptor.[[VectorLength]], filled with 0.</li><li>return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></li><li>Let <var>result</var> be <a href="#simd-scalar">SIMDScalarOp</a>(<var>a</var>, <var>scalar</var>, <code>&gt;&gt;&gt;</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>Unlike ECMAScript scalar shift, there is no "wrap-around" behavior.</emu-note>
</emu-clause>

<emu-clause id="simd-shift-right-arithmetic-by-scalar">
<h1><span class="secnum">6.2.41</span><var>SIMD</var>Constructor.shiftRightArithmeticByScalar( a, bits )<span class="utils"><span class="anchor"><a href="#simd-shift-right-arithmetic-by-scalar">#</a></span></span></h1>
This operation is only defined on unsigned integer SIMD types. This definition uses the refers to <code>&gt;&gt;</code> as defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-signed-right-shift-operator">ES2015 12.8.4 (The Signed Right Shift Operator ( &gt;&gt; ))</a>.
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>scalar</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-touint32">ToUint32</a>(<var>bits</var>).</li><li>If <var>scalar</var> ≥ <var>SIMD</var>Descriptor.[[ElementSize]] × 8, then<ol><li>Let <var>scalar</var> be <var>SIMD</var>Descriptor.[[ElementSize]] × 8 - 1.</li></ol></li><li>Let <var>result</var> be <a href="#simd-scalar">SIMDScalarOp</a>(<var>a</var>, <var>scalar</var>, <code>&gt;&gt;</code>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span>Unlike ECMAScript scalar shift, there is no "wrap-around" behavior.</emu-note>
</emu-clause>

<emu-clause id="simd-horizontal-sum">
<h1><span class="secnum">6.2.42</span><var>SIMD</var>Constructor.horizontalSum( a )<span class="utils"><span class="anchor"><a href="#simd-horizontal-sum">#</a></span></span></h1>



<emu-note><span class="note">Note</span>This operation is still under discussion. See  <a href="https://github.com/tc39/ecmascript_simd/issues/135">this bug thread</a>.</emu-note>
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>sum</var> be 0.</li><li>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>Let <var>sum</var> be <var>sum</var> + <var>a</var>.[[SIMDElements]][<var>i</var>].</li></ol></li><li>Return <var>sum</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="absolute-difference" aoid="AbsoluteDifference">
<h1><span class="secnum">6.2.43</span>AbsoluteDifference( a, b )<span class="utils"><span class="anchor"><a href="#absolute-difference">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-call-f-v-args">Call</a>(%Math_abs%, %Math%, «<var>a</var> - <var>b</var>»).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-absolute-difference">
<h1><span class="secnum">6.2.44</span><var>SIMD</var>Constructor.absoluteDifference( a, b )<span class="utils"><span class="anchor"><a href="#simd-absolute-difference">#</a></span></span></h1>
This operation is only defined on unsigned integer SIMD types whose <var>SIMD</var>Descriptor.[[ElementSize]] ≤ 2.
<emu-note><span class="note">Note</span>This operation is still under discussion. See  <a href="https://github.com/tc39/ecmascript_simd/issues/135">this bug thread</a>.</emu-note>
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>result</var> be <a href="#simd-binary">SIMDBinaryOp</a>(<var>a</var>, <var>b</var>, AbsoluteDifference).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-widened-absolute-difference">
<h1><span class="secnum">6.2.45</span><var>SIMD</var>Constructor.widenedAbsoluteDifference( a, b )<span class="utils"><span class="anchor"><a href="#simd-widened-absolute-difference">#</a></span></span></h1>
This operation is only defined on unsigned integer SIMD types whose <var>SIMD</var>Descriptor.[[ElementSize]] ≤ 2.
<emu-note><span class="note">Note</span>This operation is still under discussion. See  <a href="https://github.com/tc39/ecmascript_simd/issues/135">this bug thread</a>. To use this operation and get at the upper half of a vector, a shuffle is required.</emu-note>
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>If <var>SIMD</var>Descriptor is <code>Int8x16</code>, then let <var>outputDescriptor</var> be <code>Int16x8</code>.</li><li>Else, Assert <var>SIMD</var>Descriptor is <code>Int16x8</code>; let <var>outputDescriptor</var> be <code>Int32x4</code>.</li><li>Let <var>list</var> be a new List of length <var>descriptor</var>.[[VectorLength]].</li><li>For <var>i</var> from 0 to <var>outputDescriptor</var>.[[VectorLength]],<ol><li>Let <var>ax</var> = <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>a</var>, <var>i</var>).</li><li>Let <var>bx</var> = <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>b</var>, <var>i</var>).</li><li>Let <var>res</var> = <a href="#absolute-difference">AbsoluteDifference</a>(<var>ax</var>, <var>bx</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>res</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>res</var>.</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>outputDescriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-extract-lane">
<h1><span class="secnum">6.2.46</span><var>SIMD</var>Constructor.extractLane( simd, lane )<span class="utils"><span class="anchor"><a href="#simd-extract-lane">#</a></span></span></h1>
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Return <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>simd</var>, <var>lane</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-replace-lane">
<h1><span class="secnum">6.2.47</span><var>SIMD</var>Constructor.replaceLane(simd, lane, value)<span class="utils"><span class="anchor"><a href="#simd-replace-lane">#</a></span></span></h1>
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>Return <a href="#simd-abstract-replace-lane">SIMDReplaceLane</a>(<var>simd</var>, <var>lane</var>, <var>value</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store-function">
<h1><span class="secnum">6.2.48</span><var>SIMD</var>Constructor.store(tarray, index, simd)<span class="utils"><span class="anchor"><a href="#simd-store-function">#</a></span></span></h1>
This is defined when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.

This operation exists only on integer and floating point SIMD types.

<emu-note><span class="note">Note</span>The first seven steps of the following <code>store</code>/<code>load</code> functions are very similar. A refactoring could reduce the spec size.</emu-note>
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] field, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] × <var>SIMD</var>Descriptor.[[VectorLength]] &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li><a href="#simd-store">SIMDStore</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, <var>simd</var>).</li><li>Return <var>simd</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store1">
<h1><span class="secnum">6.2.49</span><var>SIMD</var>Constructor.store1(tarray, index, simd)<span class="utils"><span class="anchor"><a href="#simd-store1">#</a></span></span></h1>
This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4, and when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.

This operation exists only on integer and floating point SIMD types.
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li><a href="#simd-store">SIMDStore</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, <var>simd</var>, 1).</li><li>Return <var>simd</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store2">
<h1><span class="secnum">6.2.50</span><var>SIMD</var>Constructor.store2(tarray, index, simd)<span class="utils"><span class="anchor"><a href="#simd-store2">#</a></span></span></h1>
This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4, and when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.

This operation exists only on integer and floating point SIMD types.
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] × 2 &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li><a href="#simd-store">SIMDStore</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, <var>simd</var>, 2).</li><li>Return <var>simd</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store3">
<h1><span class="secnum">6.2.51</span><var>SIMD</var>Constructor.store3(tarray, index)<span class="utils"><span class="anchor"><a href="#simd-store3">#</a></span></span></h1>
This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4, and when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.

This operation exists only on integer and floating point SIMD types.
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError.</li><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] × 3 &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li><a href="#simd-store">SIMDStore</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, 3).</li><li>Return <var>simd</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load-function">
<h1><span class="secnum">6.2.52</span><var>SIMD</var>Constructor.load(tarray, index)<span class="utils"><span class="anchor"><a href="#simd-load-function">#</a></span></span></h1>
This function is defined only on SIMD types where <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.

This operation exists only on integer and floating point SIMD types.

<emu-note><span class="note">Note</span><code>load</code> takes a TypedArray of any element type as an argument. One way to use it is to pass in a <code>Uint8Array</code> regardless of SIMD type, which is useful because it allows the compiler to eliminate the shift in going from the index to the pointer offset. Other options considered were to use an ArrayBuffer (but this is not idiomatic, to take an ArrayBuffer directly as an argument to read off of) or a DataView (but DataViews don't tend to expose platform-dependent endianness, which is important here, and they tend to use methods on <code>DataView.prototype</code>, which are harder to optimize in an asm.js context).</emu-note>
<emu-alg><ol><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ <var>tarray</var>.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] × <var>SIMD</var>Descriptor.[[VectorLength]] &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li>Return <a href="#simd-load">SIMDLoad</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load1">
<h1><span class="secnum">6.2.53</span><var>SIMD</var>Constructor.load1(tarray, index)<span class="utils"><span class="anchor"><a href="#simd-load1">#</a></span></span></h1>
This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4 and <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.

This operation exists only on integer and floating point SIMD types.
<emu-alg><ol><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li>Return <a href="#simd-load">SIMDLoad</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, 1).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load2">
<h1><span class="secnum">6.2.54</span><var>SIMD</var>Constructor.load2(tarray, index)<span class="utils"><span class="anchor"><a href="#simd-load2">#</a></span></span></h1>
This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4 and <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.

This operation exists only on integer and floating point SIMD types.
<emu-alg><ol><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] × 2 &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li>Return <a href="#simd-load">SIMDLoad</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, 2).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load3">
<h1><span class="secnum">6.2.55</span><var>SIMD</var>Constructor.load3(tarray, index)<span class="utils"><span class="anchor"><a href="#simd-load3">#</a></span></span></h1>
This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4 and <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.

This operation exists only on integer and floating point SIMD types.
<emu-alg><ol><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toint32">ToInt32</a>(<var>index</var>), throw a TypeError.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] × 3 &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError.</li><li>Return <a href="#simd-load">SIMDLoad</a>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, 3).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-to-timd">
<h1><span class="secnum">6.2.56</span><var>SIMD</var>Constructor.from<var>TIMD</var>Bits( value )<span class="utils"><span class="anchor"><a href="#simd-to-timd">#</a></span></span></h1>
In this definition, <var>TIMD</var> ranges over all SIMD types for which <var>SIMD</var>Descriptor.[[ElementSize]] × <var>SIMD</var>Descriptor.[[VectorLength]] = <var>TIMD</var>Descriptor.[[ElementSize]] × <var>TIMD</var>Descriptor.[[VectorLength]], unless one descriptor does not have a [[SerializeElement]] field.
<emu-note><span class="note">Note</span>All of the SIMD types described in this spec are 16 bytes, but Booleans have no serialization, so all pairs of types which do not include Booleans are included.</emu-note>
<emu-alg><ol><li>If <var>value</var>.[[SIMDTypeDescriptor]] is not <var>TIMD</var>Descriptor, throw a TypeError.</li><li>Return <a href="#simd-reinterpret-cast">SIMDReinterpretCast</a>(<var>value</var>, <var>SIMD</var>Descriptor).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-to-timd-logical">
<h1><span class="secnum">6.2.57</span><var>SIMD</var>Constructor.from<var>TIMD</var>( value )<span class="utils"><span class="anchor"><a href="#simd-to-timd-logical">#</a></span></span></h1>
In this definition, <var>TIMD</var> ranges over all SIMD types for which <var>SIMD</var>Descriptor.[[VectorLength]] = <var>TIMD</var>Descriptor.[[VectorLength]], and where <var>SIMD</var> and <var>TIMD</var> are not boolean types.
<emu-alg><ol><li>If <var>value</var>.[[SIMDTypeDescriptor]] is not <var>TIMD</var>Descriptor, throw a TypeError.</li><li>Let <var>list</var> be a copy of <var>value</var>.[[SIMDElements]].</li><li>For <var>element</var> in <var>list</var>,<ol><li>If <var>SIMD</var> is an integer type and <var>TIMD</var> is a floating point type, and <var>element</var> is greater than the maximum value or less than the minimum value of <var>SIMD</var>, throw a <emu-val>RangeError</emu-val>.</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="swizzle">
<h1><span class="secnum">6.2.58</span><var>SIMD</var>.swizzle( a, ...lanes )<span class="utils"><span class="anchor"><a href="#swizzle">#</a></span></span></h1>



<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val>.</li><li>Let <var>indices</var> be a new List.</li><li>For integer <var>n</var> from <emu-val>0</emu-val> to <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Let <var>lane</var> be <var>lanes</var>[<var>i</var>], or 0 if <var>lanes</var> is not long enough.</li><li>Let <var>index</var> be <a href="#simd-to-lane">SIMDToLane</a>(<var>value</var>.[[SIMDTypeDescriptor]].[[VectorLength]], <var>lane</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>index</var>).</li><li>Append <var>index</var> to the end of <var>indices</var>.</li></ol></li><li>Let <var>fields</var> be a new List of length <var>SIMD</var>Descriptor.[[VectorLength]].</li><li>For <var>i</var> in from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>Set <var>fields</var>[<var>i</var>] to <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>a</var>, <var>indices</var>[<var>i</var>])</li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>fields</var>).</li></ol></emu-alg>
The <code>length</code> property of <code>_SIMD_.swizzle</code> is 1 + <var>SIMD</var>Descriptor.[[VectorLength]].
</emu-clause>

<emu-clause id="shuffle">
<h1><span class="secnum">6.2.59</span><var>SIMD</var>.shuffle( a, b, ...lanes )<span class="utils"><span class="anchor"><a href="#shuffle">#</a></span></span></h1>



<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, or if <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val>.</li><li>Let <var>indices</var> be a new List.</li><li>For integer <var>n</var> from <emu-val>0</emu-val> to <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Let <var>lane</var> be <var>lanes</var>[<var>i</var>], or 0 if <var>lanes</var> is not long enough.</li><li>Let <var>index</var> be <a href="#simd-to-lane">SIMDToLane</a>(<var>SIMD</var>Descriptor.[[VectorLength]] * 2, <var>lane</var>).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>index</var>).</li><li>Append <var>index</var> to the end of <var>indices</var>.</li></ol></li><li>Let <var>fields</var> be a new List of length <var>SIMD</var>Descriptor.[[VectorLength]].</li><li>For <var>i</var> in from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>Let <var>idx</var> be <var>indices</var>[<var>i</var>].</li><li>If <var>idx</var> ≥ <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Set <var>fields</var>[<var>i</var>] to <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>b</var>, <var>idx</var> - <var>SIMD</var>Descriptor.[[VectorLength]])</li></ol></li><li>Otherwise,<ol><li>Set <var>fields</var>[<var>i</var>] to <a href="#simd-abstract-extract-lane">SIMDExtractLane</a>(<var>a</var>, <var>idx</var>)</li></ol></li></ol></li><li>Return <a href="#simd-create">SIMDCreate</a>(<var>SIMD</var>Descriptor, <var>fields</var>).</li></ol></emu-alg>
The <code>length</code> property of <code>_SIMD_.shuffle</code> is 2 + <var>SIMD</var>Descriptor.[[VectorLength]] * 2.
</emu-clause>

</emu-clause>

<emu-clause id="simd-proto">
<h1><span class="secnum">6.3</span>The <var>SIMD</var>Constructor.prototype<span class="utils"><span class="anchor"><a href="#simd-proto">#</a></span></span></h1>

<emu-clause id="simd-proto-constructor">
<h1><span class="secnum">6.3.1</span><var>SIMD</var>Constructor.prototype.constructor<span class="utils"><span class="anchor"><a href="#simd-proto-constructor">#</a></span></span></h1>


</emu-clause>

<emu-clause id="simd-prototype-valueof">
<h1><span class="secnum">6.3.2</span><var>SIMD</var>Constructor.prototype.valueOf()<span class="utils"><span class="anchor"><a href="#simd-prototype-valueof">#</a></span></span></h1>
<emu-alg><ol><li>If <emu-val>this</emu-val> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val>.</li><li>If <emu-val>this</emu-val>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val>.</li><li>Return <emu-val>this</emu-val>.[[SIMDWrapperData]].</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-prototype-tolocalestring">
<h1><span class="secnum">6.3.3</span><var>SIMD</var>Constructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )<span class="utils"><span class="anchor"><a href="#simd-prototype-tolocalestring">#</a></span></span></h1>
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the <code>TypedArray.prototype.toLocaleString</code> method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the <code>toLocaleString</code> method is used.

<emu-note><span class="note">Note</span>The first and second editions of ECMA-402 did not include a replacement specification for the TypedArray.prototype.toLocaleString method.</emu-note>


<emu-alg><ol><li>If <emu-val>this</emu-val> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val>.</li><li>If <emu-val>this</emu-val>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>separator</var> be the String value for the list-separator String appropriate for the host environment’s current locale (this is derived in an implementation-defined way).</li><li>Let <var>list</var> be an empty List</li><li>For each element <var>element</var> in <var>argument</var>.[[SIMDElements]],<ol><li>Let <var>R</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tostring">ToString</a>(<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-invoke">Invoke</a>(<var>element</var>, "toLocaleString")).</li><li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt">ReturnIfAbrupt</a>(<var>R</var>).</li><li>Append <var>R</var> to <var>list</var>.</li></ol></li><li>Let <var>results</var> be an Array containing the contents of <var>list</var>.</li><li>Let <var>t</var> be the string <code>"</code><var>SIMD</var><code>"</code>, e.g., <code>"Float32x4"</code>.</li><li>Let <var>e</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-call-f-v-args">Call</a>(%ArrayPrototype_join%, <var>results</var>, «<var>separator</var>»).</li><li>Return a new String value computed by concatenating the previous value of <var>t</var>, "(", <var>e</var>, and ")".</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-prototype-tostring">
<h1><span class="secnum">6.3.4</span><var>SIMD</var>Constructor.prototype.toString()<span class="utils"><span class="anchor"><a href="#simd-prototype-tostring">#</a></span></span></h1>
<emu-alg><ol><li>If <emu-val>this</emu-val> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val>.</li><li>If <emu-val>this</emu-val>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tostring">ToString</a>(<emu-val>this</emu-val>.[[SIMDWrapperData]]).</li></ol></emu-alg>
<emu-note><span class="note">Note</span>This definition depends on the primitive <var>SIMD</var>Type's behavior under ToString. Alternatively, <var>SIMD</var>Type could have ToString defined by calling ToObject and then reaching this method (or whatever the user overrides it with), in which case the current definition in ToString would be brought down here.</emu-note>
</emu-clause>

<emu-clause id="simd-to-string-tag">
<h1><span class="secnum">6.3.5</span><var>SIMD</var>Constructor.prototype [ @@toStringTag ]<span class="utils"><span class="anchor"><a href="#simd-to-string-tag">#</a></span></span></h1>



</emu-clause>

<emu-clause id="simd-to-primitive">
<h1><span class="secnum">6.3.6</span><var>SIMD</var>Constructor.prototype [ @@toPrimitive ] ( hint )<span class="utils"><span class="anchor"><a href="#simd-to-primitive">#</a></span></span></h1>
<emu-note><span class="note">Note</span>
This function is called by ECMAScript language operators to convert a Symbol object to a primitive value. The allowed values for hint are <code>"default"</code>, <code>"number"</code>, and <code>"string"</code>.
</emu-note>



<emu-alg><ol><li>Let <var>s</var> be the <emu-val>this</emu-val> value.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>s</var>) is a SIMD type, return <var>s</var>.</li><li>If <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-data-types-and-values">Type</a>(<var>s</var>) is not <code>Object</code>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>s</var> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>s</var>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return the value of <var>s</var>’s [[SIMDWrapperData]] internal slot.</li></ol></emu-alg>



</emu-clause>

</emu-clause>

<emu-clause id="simd-descriptors">
<h1><span class="secnum">6.4</span>SIMD type descriptors<span class="utils"><span class="anchor"><a href="#simd-descriptors">#</a></span></span></h1>
This section describes the SIMD type descriptors, which are organized as described in the %SIMD% section.

In the internal algorithms in this section, preceding the first step, if <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time one of the following algorithms is executed, and it must be consistent across all algorithms.

<emu-clause id="simd-float32x4">
<h1><span class="secnum">6.4.1</span>Float32x4Descriptor type descriptor<span class="utils"><span class="anchor"><a href="#simd-float32x4">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 4</li>
<li>[[ElementSize]]: 4</li>
<li>[[CastNumber]]: %Math_fround%</li>
<li>[[SerializeElement]]: SerializeFloat32</li>
<li>[[DeserializeElement]]: DeserializeFloat32</li>
</ul>

<emu-clause id="serialize-float32" aoid="SerializeFloat32">
<h1><span class="secnum">6.4.1.1</span>SerializeFloat32( block, offset, n, isLittleEndian )<span class="utils"><span class="anchor"><a href="#serialize-float32">#</a></span></span></h1>
<emu-note><span class="note">Note</span>Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-setvalueinbuffer">SetValueInBuffer</a>. Note that this specification does not require a particular bit pattern for <emu-val>NaN</emu-val>, and that it does not need to be the same across calls.</emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a Data Block.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>n</var> is a number.</li><li>Assert: <var>offset</var> + 4 is less than or equal to the size of <var>block</var>.</li><li>Set <var>rawBytes</var> to a List containing the 4 bytes that are the result of converting value to IEEE 754-2008 binary32 format using “Round to nearest, ties to even” rounding mode. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If value is <emu-val>NaN</emu-val>, <var>rawValue</var> may be set to any implementation chosen <emu-val>NaN</emu-val> encoding. An implementation must always choose the same <emu-val>NaN</emu-val> encoding for a distinct Not-a-Number value.</li><li>Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>offset</var>].</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-float32" aoid="DeserializeFloat32">
<h1><span class="secnum">6.4.1.2</span>DeserializeFloat32( block, offset, isLittleEndian )<span class="utils"><span class="anchor"><a href="#deserialize-float32">#</a></span></span></h1>
<emu-note><span class="note">Note</span>Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getvaluefrombuffer">GetValueFromBuffer</a>. Note that while this says to return "the <emu-val>NaN</emu-val> value", the binary representation is not observable and canonicalization is not required.</emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a Data Block.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>offset</var> + 4 is less than or equal to the size of <var>block</var>.</li><li>Let <var>rawValue</var> be a List of 4 containing, in order, the sequence of 4 bytes starting with <var>block</var>[<var>offset</var>].</li><li>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawValue</var>.</li><li>Let <var>value</var> be the byte elements of rawValue concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.</li><li>If <var>value</var> is an IEEE 754-2008 binary32 <emu-val>NaN</emu-val> value, return the <emu-val>NaN</emu-val> Number value.</li><li>Return the Number value that corresponds to <var>value</var>.</li></ol></emu-alg>
</emu-clause>
</emu-clause>

<emu-clause id="simd-int32x4">
<h1><span class="secnum">6.4.2</span>Int32x4Descriptor type descriptor<span class="utils"><span class="anchor"><a href="#simd-int32x4">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 4</li>
<li>[[ElementSize]]: 4</li>
<li>[[CastNumber]]: ToInt32</li>
<li>[[SerializeElement]]: SerializeInt32</li>
<li>[[DeserializeElement]]: DeserializeInt32</li>
<li>[[ElementMax]]: 2<sup>31</sup>-1</li>
<li>[[ElementMin]]: -2<sup>31</sup></li>
</ul>

<emu-clause id="serialize-int" aoid="SerializeInt">
<h1><span class="secnum">6.4.2.1</span>SerializeInt( block, offset, n, isLittleEndian, descriptor )<span class="utils"><span class="anchor"><a href="#serialize-int">#</a></span></span></h1>
<emu-note><span class="note">Note</span>Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-setvalueinbuffer">SetValueInBuffer</a>.</emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a Data Block.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>n</var> is a number.</li><li>Assert: <var>n</var> = <var>descriptor</var>.[[CastNumber]](<var>n</var>).</li><li>Assert: <var>offset</var> + <var>descriptor</var>.[[ElementSize]] is less than or equal to the size of <var>block</var>.</li><li>Let <var>rawBytes</var> be a List containing the <var>descriptor</var>.[[ElementSize]]-byte binary 2’s complement encoding of <var>n</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</li><li>Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>offset</var>].</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-int" aoid="DeserializeInt">
<h1><span class="secnum">6.4.2.2</span>DeserializeInt( block, offset, isLittleEndian, descriptor )<span class="utils"><span class="anchor"><a href="#deserialize-int">#</a></span></span></h1>
<emu-note><span class="note">Note</span>Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getvaluefrombuffer">GetValueFromBuffer</a>.</emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a Data Block.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>offset</var> + <var>descriptor</var>.[[ElementSize]] is less than or equal to the size of <var>block</var>.</li><li>Let <var>rawValue</var> be a List of <var>descriptor</var>.[[ElementSize]] containing, in order, the sequence of <var>descriptor</var>.[[ElementSize]] bytes starting with <var>block</var>[<var>offset</var>].</li><li>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawValue</var>.</li><li>Let <var>intValue</var> be the byte elements of <var>rawValue</var> concatenated and interpreted as a bit string encoding of an integer of bit length <var>descriptor</var>.[[ElementSize]] × 8. If <var>descriptor</var> is a signed type, interpret as signed 2's complement; if it is unsigned, interpret as an unsigned integer.</li><li>Return the Number value that corresponds to <var>intValue</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="serialize-int32" aoid="SerializeInt32">
<h1><span class="secnum">6.4.2.3</span>SerializeInt32( block, offset, n, isLittleEndian )<span class="utils"><span class="anchor"><a href="#serialize-int32">#</a></span></span></h1>
<emu-alg><ol><li><a href="#serialize-int">SerializeInt</a>( block, offset, n, isLittleEndian, Int32x4Descriptor ).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-int32" aoid="DeserializeInt32">
<h1><span class="secnum">6.4.2.4</span>DeserializeInt32( block, offset, isLittleEndian )<span class="utils"><span class="anchor"><a href="#deserialize-int32">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#deserialize-int">DeserializeInt</a>( block, offset, isLittleEndian, Int32x4Descriptor).</li></ol></emu-alg>
</emu-clause>
</emu-clause>

<emu-clause id="simd-int16x8">
<h1><span class="secnum">6.4.3</span>Int16x8Descriptor type descriptor<span class="utils"><span class="anchor"><a href="#simd-int16x8">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 8</li>
<li>[[ElementSize]]: 2</li>
<li>[[CastNumber]]: ToInt16</li>
<li>[[SerializeElement]]: SerializeInt16</li>
<li>[[DeserializeElement]]: DeserializeInt16</li>
<li>[[ElementMax]]: 2<sup>15</sup>-1</li>
<li>[[ElementMin]]: -2<sup>15</sup></li>
</ul>

<emu-clause id="serialize-int16" aoid="SerializeInt16">
<h1><span class="secnum">6.4.3.1</span>SerializeInt16( block, offset, n, isLittleEndian )<span class="utils"><span class="anchor"><a href="#serialize-int16">#</a></span></span></h1>
<emu-alg><ol><li><a href="#serialize-int">SerializeInt</a>( block, offset, n, isLittleEndian, Int16x8Descriptor ).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-int16" aoid="DeserializeInt16">
<h1><span class="secnum">6.4.3.2</span>DeserializeInt16( block, offset, isLittleEndian )<span class="utils"><span class="anchor"><a href="#deserialize-int16">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#deserialize-int">DeserializeInt</a>( block, offset, isLittleEndian, Int16x8Descriptor).</li></ol></emu-alg>
</emu-clause>

</emu-clause>

<emu-clause id="simd-int8x16">
<h1><span class="secnum">6.4.4</span>Int8x16Descriptor type descriptor<span class="utils"><span class="anchor"><a href="#simd-int8x16">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 16</li>
<li>[[ElementSize]]: 1</li>
<li>[[CastNumber]]: ToInt8</li>
<li>[[SerializeElement]]: SerializeInt8</li>
<li>[[DeserializeElement]]: DeserializeInt8</li>
<li>[[ElementMax]]: 127</li>
<li>[[ElementMin]]: -128</li>
</ul>

<emu-clause id="serialize-int8" aoid="SerializeInt8">
<h1><span class="secnum">6.4.4.1</span>SerializeInt8( block, offset, n, isLittleEndian )<span class="utils"><span class="anchor"><a href="#serialize-int8">#</a></span></span></h1>
<emu-alg><ol><li><a href="#serialize-int">SerializeInt</a>( block, offset, n, isLittleEndian, Int8x16Descriptor ).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-int8" aoid="DeserializeInt8">
<h1><span class="secnum">6.4.4.2</span>DeserializeInt8( block, offset, isLittleEndian )<span class="utils"><span class="anchor"><a href="#deserialize-int8">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#deserialize-int">DeserializeInt</a>( block, offset, isLittleEndian, Int8x16Descriptor).</li></ol></emu-alg>
</emu-clause>
</emu-clause>

<emu-clause id="simd-uint32x4">
<h1><span class="secnum">6.4.5</span>Uint32x4Descriptor type descriptor<span class="utils"><span class="anchor"><a href="#simd-uint32x4">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 4</li>
<li>[[ElementSize]]: 4</li>
<li>[[CastNumber]]: ToUint32</li>
<li>[[SerializeElement]]: SerializeUint32</li>
<li>[[DeserializeElement]]: DeserializeUint32</li>
<li>[[ElementMax]]: 2<sup>32</sup>-1</li>
<li>[[ElementMin]]: 0</li>
</ul>

<emu-clause id="serialize-uint32" aoid="SerializeUint32">
<h1><span class="secnum">6.4.5.1</span>SerializeUint32( block, offset, n, isLittleEndian )<span class="utils"><span class="anchor"><a href="#serialize-uint32">#</a></span></span></h1>
<emu-alg><ol><li><a href="#serialize-int">SerializeInt</a>( block, offset, n, isLittleEndian, Uint32x4Descriptor ).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-int32" aoid="DeserializeInt32">
<h1><span class="secnum">6.4.5.2</span>DeserializeUint32( block, offset, isLittleEndian )<span class="utils"><span class="anchor"><a href="#deserialize-int32">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#deserialize-int">DeserializeInt</a>( block, offset, isLittleEndian, Uint32x4Descriptor).</li></ol></emu-alg>
</emu-clause>
</emu-clause>

<emu-clause id="simd-uint16x8">
<h1><span class="secnum">6.4.6</span>Uint16x8Descriptor type descriptor<span class="utils"><span class="anchor"><a href="#simd-uint16x8">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 8</li>
<li>[[ElementSize]]: 2</li>
<li>[[CastNumber]]: ToUint16</li>
<li>[[SerializeElement]]: SerializeUint16</li>
<li>[[DeserializeElement]]: DeserializeUint16</li>
<li>[[ElementMax]]: 2<sup>16</sup>-1</li>
<li>[[ElementMin]]: 0</li>
</ul>

<emu-clause id="serialize-uint16" aoid="SerializeUint16">
<h1><span class="secnum">6.4.6.1</span>SerializeUint16( block, offset, n, isLittleEndian )<span class="utils"><span class="anchor"><a href="#serialize-uint16">#</a></span></span></h1>
<emu-alg><ol><li><a href="#serialize-int">SerializeInt</a>( block, offset, n, isLittleEndian, Uint16x8Descriptor ).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-uint16" aoid="DeserializeUint16">
<h1><span class="secnum">6.4.6.2</span>DeserializeUint16( block, offset, isLittleEndian )<span class="utils"><span class="anchor"><a href="#deserialize-uint16">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#deserialize-int">DeserializeInt</a>( block, offset, isLittleEndian, Uint16x8Descriptor).</li></ol></emu-alg>
</emu-clause>

</emu-clause>

<emu-clause id="simd-uint8x16">
<h1><span class="secnum">6.4.7</span>Uint8x16Descriptor type descriptor<span class="utils"><span class="anchor"><a href="#simd-uint8x16">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 16</li>
<li>[[ElementSize]]: 1</li>
<li>[[CastNumber]]: ToUint8</li>
<li>[[SerializeElement]]: SerializeUint8</li>
<li>[[DeserializeElement]]: DeserializeUint8</li>
<li>[[ElementMax]]: 255</li>
<li>[[ElementMin]]: 0</li>
</ul>

<emu-clause id="serialize-uint8" aoid="SerializeUint8">
<h1><span class="secnum">6.4.7.1</span>SerializeUint8( block, offset, n, isLittleEndian )<span class="utils"><span class="anchor"><a href="#serialize-uint8">#</a></span></span></h1>
<emu-alg><ol><li><a href="#serialize-int">SerializeInt</a>( block, offset, n, isLittleEndian, Uint8x16Descriptor ).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-int8" aoid="DeserializeInt8">
<h1><span class="secnum">6.4.7.2</span>DeserializeInt8( block, offset, isLittleEndian )<span class="utils"><span class="anchor"><a href="#deserialize-int8">#</a></span></span></h1>
<emu-alg><ol><li>Return <a href="#deserialize-int">DeserializeInt</a>( block, offset, isLittleEndian, Int8x16Descriptor).</li></ol></emu-alg>
</emu-clause>
</emu-clause>

<emu-clause id="simd-bool32x4">
<h1><span class="secnum">6.4.8</span>Bool32x4 type descriptor<span class="utils"><span class="anchor"><a href="#simd-bool32x4">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 4</li>
<li>[[CastNumber]]: ToBoolean</li>
</ul>
</emu-clause>

<emu-clause id="simd-bool16x8">
<h1><span class="secnum">6.4.9</span>Bool16x8 type descriptor<span class="utils"><span class="anchor"><a href="#simd-bool16x8">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 8</li>
<li>[[CastNumber]]: ToBoolean</li>
</ul>
</emu-clause>

<emu-clause id="simd-bool8x16">
<h1><span class="secnum">6.4.10</span>Bool8x16 type descriptor<span class="utils"><span class="anchor"><a href="#simd-bool8x16">#</a></span></span></h1>



<ul>
<li>[[VectorLength]]: 16</li>
<li>[[CastNumber]]: ToBoolean</li>
</ul>
</emu-clause>

</emu-clause>
</emu-clause>
</body>